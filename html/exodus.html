<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exodus API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exodus</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import builtins
import warnings
import netCDF4 as nc
import numpy
from typing import Tuple
from ledger import Ledger
import util
from constants import *
from dataclasses import dataclass


@dataclass
class ElemBlockParam:
    &#34;&#34;&#34;Stores data used to create a side set node count list.&#34;&#34;&#34;
    # Adapted from exodusII_int.h on SEACAS
    elem_type_str: str
    elem_blk_id: numpy.int64
    num_elem_in_blk: numpy.int64
    num_nodes_per_elem: int
    num_sides: int
    num_nodes_per_side: numpy.ndarray
    num_attr: int
    elem_ctr: numpy.int64
    elem_type_val: ElementTopography


class Exodus:
    _FORMAT_MAP = {&#39;EX_NETCDF4&#39;: &#39;NETCDF4&#39;,
                   &#39;EX_LARGE_MODEL&#39;: &#39;NETCDF3_64BIT_OFFSET&#39;,
                   &#39;EX_NORMAL_MODEL&#39;: &#39;NETCDF3_CLASSIC&#39;,
                   &#39;EX_64BIT_DATA&#39;: &#39;NETCDF3_64BIT_DATA&#39;}
    # Default values
    _MAX_STR_LENGTH = 32
    _MAX_STR_LENGTH_T = &#39;U32&#39;
    _MAX_NAME_LENGTH = 32
    _MAX_LINE_LENGTH = 80
    _MAX_LINE_LENGTH_T = &#39;U80&#39;
    _EXODUS_VERSION = 7.22

    # Should creating a new file (mode &#39;w&#39;) be a function on its own?
    def __init__(self, path, mode, shared=False, format=&#39;EX_NETCDF4&#39;, word_size=4):
        # clobber and format and word_size only apply to mode w
        if mode not in [&#39;r&#39;, &#39;w&#39;, &#39;a&#39;]:
            raise ValueError(&#34;mode must be &#39;w&#39;, &#39;r&#39;, or &#39;a&#39;, got &#39;{}&#39;&#34;.format(mode))
        if format not in Exodus._FORMAT_MAP.keys():
            raise ValueError(&#34;invalid file format: &#39;{}&#39;&#34;.format(format))
        if word_size not in [4, 8]:
            raise ValueError(&#34;word_size must be 4 or 8 bytes, {} is not supported&#34;.format(word_size))
        nc_format = Exodus._FORMAT_MAP[format]

        self.mode = mode
        self.path = path

        # file should never actually be opened in append mode
        # if append mode is specified, open file in read mode and write out changes to separate file
        if mode == &#39;a&#39;:
            mode = &#39;r&#39;

        # Sets shared mode if the user asked for it. I have no idea what this does :)
        if shared:
            smode = mode + &#39;s&#39;
        else:
            smode = mode
        try:
            self.data = nc.Dataset(path, smode, clobber=False, format=nc_format)
        except FileNotFoundError:
            raise FileNotFoundError(&#34;file &#39;{}&#39; does not exist&#34;.format(path)) from None
        except PermissionError:
            raise PermissionError(&#34;You do not have access to &#39;{}&#39;&#34;.format(path)) from None
        # TODO this can actually hide some errors which is bad. This check should be done explicitly
        except OSError:
            raise OSError(&#34;file &#39;{}&#39; already exists&#34;.format(path)) from None



        if self.mode == &#39;w&#39;:
            # This is important according to ex_open.c
            self.data.set_fill_off()

        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            self.ledger = Ledger(self)

        # save path variable for future use
        self.path = path

        # We will read a bunch of data here to make sure it exists and warn the user if they might want to fix their
        # file. We don&#39;t save anything to memory so that if our data updates we don&#39;t have to update it in memory too.
        # This is the same practice used in the C library so its probably a good idea.

        # Initialize all the important parameters
        if mode == &#39;w&#39;:
            self.data.setncattr(&#39;title&#39;, &#39;Untitled database&#39;)
            self.data.createDimension(&#39;len_string&#39;, Exodus._MAX_STR_LENGTH + 1)
            self.data.createDimension(&#39;len_name&#39;, Exodus._MAX_NAME_LENGTH + 1)
            self.data.createDimension(&#39;len_line&#39;, Exodus._MAX_LINE_LENGTH + 1)
            self.data.setncattr(&#39;maximum_name_length&#39;, Exodus._MAX_NAME_LENGTH)
            self.data.setncattr(&#39;version&#39;, Exodus._EXODUS_VERSION)
            self.data.setncattr(&#39;api_version&#39;, Exodus._EXODUS_VERSION)
            self.data.setncattr(&#39;floating_point_word_size&#39;, word_size)
            file_size = 0
            if nc_format == &#39;NETCDF3_64BIT_OFFSET&#39;:
                file_size = 1
            self.data.setncattr(&#39;file_size&#39;, file_size)
            int64bit_status = 0
            if nc_format == &#39;NETCDF3_64BIT_DATA&#39;:
                int64bit_status = 1
            self.data.setncattr(&#39;int64_status&#39;, int64bit_status)

        # TODO Uncomment these later
        #  The C library doesn&#39;t seem to care if the file is in read or modify mode when it does this
        # Add this if it doesn&#39;t exist (value of 33)
        # if &#39;len_name&#39; not in self.data.dimensions:
        #     warnings.warn(&#34;&#39;len_name&#39; dimension is missing!&#34;)

        # Add this if it doesn&#39;t exist (value of 32)
        # if &#39;maximum_name_length&#39; not in self.data.ncattrs():
        #     warnings.warn(&#34;&#39;maximum_name_length&#39; attribute is missing!&#34;)

        # Check version compatibility
        ver = self.version
        if ver &lt; 2.0:
            raise RuntimeError(
                &#34;Unsupported file version {:.2f}! Only versions &gt;2.0 are supported.&#34;.format(ver))

        # Read word size stored in file
        ws = self.word_size
        if ws == 4:
            self._float = numpy.float32
        elif ws == 8:
            self._float = numpy.float64
        else:
            raise ValueError(&#34;file contains a word size of {} which is not supported&#34;.format(ws))

        if self.int64_status == 0:
            self._int = numpy.int32
        else:
            self._int = numpy.int64

        # important for storing names in numpy arrays
        self._MAX_NAME_LENGTH_T = &#39;U%s&#39; % self.max_allowed_name_length

    def to_float(self, n):
        &#34;&#34;&#34;Returns ``n`` converted to the floating-point type stored in the database.&#34;&#34;&#34;
        # Convert a number to the floating point type the database is using
        return self._float(n)

    def to_int(self, n):
        &#34;&#34;&#34;Returns ``n`` converted to the integer type stored in the database.&#34;&#34;&#34;
        # Convert a number to the integer type the database is using
        return self._int(n)

    @property
    def float(self):
        &#34;&#34;&#34;The floating-point type stored in the database.&#34;&#34;&#34;
        # Returns floating point type of floating point numbers stored in the database
        # You may use whatever crazy types you want while coding, but convert them before storing them in the DB
        return self._float

    @property
    def int(self):
        &#34;&#34;&#34;The integer type stored in the database.&#34;&#34;&#34;
        # Returns integer type of integers stored in the database
        return self._int

    ########################################################################
    #                                                                      #
    #                        Data File Utilities                           #
    #                                                                      #
    ########################################################################

    # GLOBAL PARAMETERS AND MODEL DEFINITION

    # region Properties

    # TODO perhaps in-place properties like these could have property setters as well

    # TODO it would be nice to have the return values cached for these so they execute faster and act more like
    #  properties and less like small functions. This will require some write integration.

    @property
    def title(self):
        &#34;&#34;&#34;The database title.&#34;&#34;&#34;
        try:
            return self.data.getncattr(ATT_TITLE)
        except AttributeError:
            AttributeError(&#34;Database title could not be found&#34;)

    @property
    def max_allowed_name_length(self):
        &#34;&#34;&#34;The maximum allowed length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
        max_name_len = Exodus._MAX_NAME_LENGTH
        if DIM_NAME_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra null character is added for C reasons
            max_name_len = self.data.dimensions[DIM_NAME_LENGTH].size - 1
        return max_name_len

    @property
    def max_used_name_length(self):
        &#34;&#34;&#34;The maximum used length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
        # 32 is the default size consistent with other databases
        max_used_name_len = 32
        if ATT_MAX_NAME_LENGTH in self.data.ncattrs():
            # The length does not include the added null character from C
            max_used_name_len = self.data.getncattr(ATT_MAX_NAME_LENGTH)
        return max_used_name_len

    @property
    def max_string_length(self):
        &#34;&#34;&#34;Maximum QA record string length.&#34;&#34;&#34;
        # See ex_put_qa.c @ line 119. This record is created and used when adding QA records
        max_str_len = Exodus._MAX_STR_LENGTH
        if DIM_STRING_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra character is added for C reasons
            max_str_len = self.data.dimensions[DIM_STRING_LENGTH].size - 1
        return max_str_len

    @property
    def max_line_length(self):
        &#34;&#34;&#34;Maximum info record line length.&#34;&#34;&#34;
        # See ex_put_info.c @ line 121. This record is created and used when adding info records
        max_line_len = Exodus._MAX_LINE_LENGTH
        if DIM_LINE_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra character is added for C reasons
            max_line_len = self.data.dimensions[DIM_LINE_LENGTH].size - 1
        return max_line_len

    @property
    def api_version(self):
        &#34;&#34;&#34;The Exodus API version this database was built with.&#34;&#34;&#34;
        try:
            result = self.data.getncattr(ATT_API_VER)
        except AttributeError:
            # Try the old way of spelling it
            try:
                result = self.data.getncattr(ATT_API_VER_OLD)
            except AttributeError:
                raise AttributeError(&#34;Exodus API version could not be found&#34;)
        return result

    @property
    def version(self):
        &#34;&#34;&#34;The Exodus version this database uses.&#34;&#34;&#34;
        try:
            return self.data.getncattr(ATT_VERSION)
        except AttributeError:
            raise AttributeError(&#34;Exodus database version could not be found&#34;)

    @property
    def large_model(self):
        &#34;&#34;&#34;
        Describes how coordinates are stored in this database.

        If true: nodal coordinates and variables are stored in separate x, y, z variables.
        If false: nodal coordinates and variables are stored in a single variable.

        :return: 1 if stored separately (large), 0 if stored in a blob
        &#34;&#34;&#34;
        # According to a comment in ex_utils.c @ line 1614
        # &#34;Basically, the difference is whether the coordinates and nodal variables are stored in a blob (xyz components
        # together) or as a variable per component per nodal_variable.&#34;
        # This is important for coordinate getter functions
        if ATT_FILE_SIZE in self.data.ncattrs():
            return self.data.getncattr(ATT_FILE_SIZE)
        else:
            return 0
            # No warning is raised because older files just don&#39;t have this

    @property
    def int64_status(self):
        &#34;&#34;&#34;
        64-bit integer support for this database.

        Use ``int()`` to get the integer type used by this database.

        :return: 1 if 64-bit integers are supported, 0 otherwise
        &#34;&#34;&#34;
        # Determines whether the file uses int64s
        if ATT_64BIT_INT in self.data.ncattrs():
            return self.data.getncattr(ATT_64BIT_INT)
        else:
            return 1 if self.data.data_model == &#39;NETCDF3_64BIT_DATA&#39; else 0
            # No warning is raised because older files just don&#39;t have this

    @property
    def word_size(self):
        &#34;&#34;&#34;
        Word size of floating point variables in this database.

        Use ``float()`` to get the float type used by this database.

        :return: floating point word size
        &#34;&#34;&#34;
        try:
            result = self.data.getncattr(ATT_WORD_SIZE)
        except AttributeError:
            try:
                result = self.data.getncattr(ATT_WORD_SIZE_OLD)
            except AttributeError:
                # This should NEVER happen, but here to be safe
                raise AttributeError(&#34;Exodus database floating point word size could not be found&#34;)
        return result

    @property
    def num_qa(self):
        &#34;&#34;&#34;Number of QA records.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_QA].size
        except KeyError:
            result = 0
        return result

    @property
    def num_info(self):
        &#34;&#34;&#34;Number of info records.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_INFO].size
        except KeyError:
            result = 0
        return result

    @property
    def num_dim(self):
        &#34;&#34;&#34;Number of dimensions (coordinate axes) used in the model.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_DIM].size
        except KeyError:
            raise KeyError(&#34;Database dimensionality could not be found&#34;)

    @property
    def num_nodes(self):
        &#34;&#34;&#34;Number of nodes stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_NODES].size
        except KeyError:
            # This and following functions don&#39;t actually error in C, they return 0. I assume there&#39;s a good reason.
            result = 0
        return result

    @property
    def num_elem(self):
        &#34;&#34;&#34;Number of elements stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_ELEM].size
        except KeyError:
            result = 0
        return result

    @property
    def num_elem_blk(self):
        &#34;&#34;&#34;Number of element blocks stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_EB].size
        except KeyError:
            result = 0
        return result

    @property
    def num_node_sets(self):
        &#34;&#34;&#34;Number of node sets stored in this database.&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.num_node_sets()

        try:
            result = self.data.dimensions[DIM_NUM_NS].size
        except KeyError:
            result = 0
        return result

    @property
    def num_side_sets(self):
        &#34;&#34;&#34;Number of side sets stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_SS].size
        except KeyError:
            result = 0
        return result

    @property
    def num_time_steps(self):
        &#34;&#34;&#34;Number of time steps stored in this database.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_TIME_STEP].size
        except KeyError:
            raise KeyError(&#34;Number of database time steps could not be found&#34;)

    @property
    def num_elem_block_prop(self):
        &#34;&#34;&#34;Number of element block properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_EB_PROP)

    @property
    def num_node_set_prop(self):
        &#34;&#34;&#34;Number of node set properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_NS_PROP)

    @property
    def num_side_set_prop(self):
        &#34;&#34;&#34;Number of side set properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_SS_PROP)

    @property
    def num_global_var(self):
        &#34;&#34;&#34;Number of global variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_GLO_VAR].size
        except KeyError:
            return 0

    @property
    def num_node_var(self):
        &#34;&#34;&#34;Number of nodal variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_NOD_VAR].size
        except KeyError:
            return 0

    @property
    def num_elem_block_var(self):
        &#34;&#34;&#34;Number of elemental variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_ELEM_VAR].size
        except KeyError:
            return 0

    @property
    def num_node_set_var(self):
        &#34;&#34;&#34;Number of node set variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_NS_VAR].size
        except KeyError:
            return 0

    @property
    def num_side_set_var(self):
        &#34;&#34;&#34;Number of side set variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_SS_VAR].size
        except KeyError:
            return 0

    # endregion

    # MODEL VARIABLE ACCESSORS

    # region Get methods

    ##############
    # Order maps #
    ##############

    def get_elem_order_map(self):
        &#34;&#34;&#34;Returns the optional element order map for this database.&#34;&#34;&#34;
        num_elem = self.num_elem
        if num_elem == 0:
            warnings.warn(&#34;Cannot retrieve an element order map if there are no elements!&#34;)
            return
        if VAR_ELEM_ORDER_MAP not in self.data.variables:
            # Return a default array from 1 to the number of elements
            warnings.warn(&#34;There is no element order map in this database!&#34;)
            return numpy.arange(1, num_elem + 1, dtype=self.int)
        return self.data.variables[VAR_ELEM_ORDER_MAP][:]

    # OK so we have two types of maps on the database: ID maps &amp; ORDER maps (also called NUMBER maps).
    # ID maps used to be called number maps and number maps used to be called order maps, which is super confusing.
    # This library supports the classic element order map (as defined in Exodus II API documentation), but does not
    # support the new &#39;number maps&#39; that the SEACAS C library has support for.

    ###########
    # ID maps #
    ###########

    # Below is an explanation of entity IDs in lieu of a proper one in any official documentation.
    # Nodes and elements have two IDs: an internal ID used by Exodus and all Exodus libraries, and a user-defined ID
    # used by analysts interacting with the database. To translate user-defined IDs to internal IDs, Exodus files store
    # an optional node ID map and element ID map. If they are not defined, user-defined IDs = internal IDs. This map
    # stores the user-defined ID for an entity at the index internal ID-1. We subtract 1 from the internal ID because
    # internal IDs are 1-based, meaning they start counting up from 1, not 0!
    # When working with element connectivity lists, we have to manually calculate the internal ID of each element since
    # connectivity lists do not store element IDs, only their constituent nodes.
    # The general formula to get the internal ID of the element at index i of element block n is as follows:
    # offset = sum(num_elem_in_block(1), num_elem_in_block(2), ..., num_elem_in_block(n - 1);
    # internal_id = offset + i + 1;
    # Example: EB1 has 7 elements, EB2 has 10 elements. The internal ID of the 4th element in EB2 is 7 + 3 + 1

    def get_node_id_map(self):
        &#34;&#34;&#34;Return the node ID map for this database.&#34;&#34;&#34;
        num_nodes = self.num_nodes
        return self.get_partial_node_id_map(1, num_nodes)

    def get_reverse_node_id_dict(self):
        &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
        nim = self.get_node_id_map()
        u2i_map = {}
        for i in range(self.num_nodes):
            u2i_map[nim[i]] = i + 1
        return u2i_map

    def get_partial_node_id_map(self, start, count):
        &#34;&#34;&#34;
        Return a subset of the node ID map for this database.

        Subset starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
        num_nodes = self.num_nodes
        if num_nodes == 0:
            raise KeyError(&#34;Cannot retrieve a node id map if there are no nodes!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;start index must be greater than 0&#34;)
        if start + count - 1 &gt; num_nodes:
            raise ValueError(&#34;start index + node count is larger than the total number of nodes&#34;)
        if VAR_NODE_ID_MAP not in self.data.variables:
            # Return a default array from start to start + count exclusive
            warnings.warn(&#34;There is no node id map in this database!&#34;)
            return numpy.arange(start, start + count, dtype=self.int)
        return self.data.variables[VAR_NODE_ID_MAP][start - 1:start + count - 1]

    def get_elem_id_map(self):
        &#34;&#34;&#34;Return the element ID map for this database.&#34;&#34;&#34;
        num_elem = self.num_elem
        return self.get_partial_elem_id_map(1, num_elem)

    def get_reverse_elem_id_dict(self):
        &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
        eim = self.get_elem_id_map()
        u2i_map = {}
        for i in range(self.num_elem):
            u2i_map[eim[i]] = i + 1
        return u2i_map

    def get_partial_elem_id_map(self, start, count):
        &#34;&#34;&#34;
        Return a subset of the element ID map for this database.

        Subset starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
        num_elem = self.num_elem
        if num_elem == 0:
            raise KeyError(&#34;Cannot retrieve a element id map if there are no elements!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;start index must be greater than 0&#34;)
        if start + count - 1 &gt; num_elem:
            raise ValueError(&#34;start index + element count is larger than the total number of elements&#34;)
        if VAR_ELEM_ID_MAP not in self.data.variables:
            # Return a default array from start to start + count exclusive
            warnings.warn(&#34;There is no element id map in this database!&#34;)
            return numpy.arange(start, start + count, dtype=self.int)
        return self.data.variables[VAR_ELEM_ID_MAP][start - 1:start + count - 1]

    def get_elem_id_map_for_block(self, obj_id):
        &#34;&#34;&#34;Reads the element ID map for the element block with specified ID.&#34;&#34;&#34;
        if self.num_elem_blk == 0:
            raise KeyError(&#34;There are no element blocks in this database!&#34;)
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        num_elem, _, _, _ = self._int_get_elem_block_params(obj_id, internal_id)
        offset = 0
        emap = self.get_elem_id_map()
        for i in range(1, internal_id):
            n, _, _, _ = self._int_get_elem_block_params(emap[i - 1], i)
            offset += n
        return self.get_partial_elem_id_map(offset + 1, num_elem)

    def get_node_set_id_map(self):
        &#34;&#34;&#34;Returns the id map for node sets (ns_prop1).&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_node_set_id_map()

        try:
            table = self.data.variables[VAR_NS_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Node set id map is missing from this database!&#34;.format(type))
        return table

    def get_side_set_id_map(self):
        &#34;&#34;&#34;Returns the id map for side sets (ss_prop1).&#34;&#34;&#34;
        try:
            table = self.data.variables[VAR_SS_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Side set id map is missing from this database!&#34;.format(type))
        return table

    def get_elem_block_id_map(self):
        &#34;&#34;&#34;Returns the id map for element blocks (eb_prop1).&#34;&#34;&#34;
        try:
            table = self.data.variables[VAR_EB_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Element block id map is missing from this database!&#34;.format(type))
        return table

    def _lookup_id(self, obj_type: ObjectType, num):
        &#34;&#34;&#34;
        Returns the internal ID of a set or block of the given type and user-defined ID.

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object this id refers to
        :param num: user-defined ID (aka number) of the set/block
        :return: internal ID
        &#34;&#34;&#34;
        if obj_type == NODESET:
            table = self.get_node_set_id_map()
        elif obj_type == SIDESET:
            table = self.get_side_set_id_map()
        elif obj_type == ELEMBLOCK:
            table = self.get_elem_block_id_map()
        else:
            raise ValueError(&#34;{} is not a valid set/block type!&#34;.format(obj_type))
        # The C library caches information about sets including whether its sequential, so it can skip a lot of this
        internal_id = 1
        for table_id in table:
            if table_id == num:
                break
            internal_id += 1
        if internal_id &gt; len(table):
            raise KeyError(&#34;Could not find set/block of type {} with id {}&#34;.format(obj_type, num))
        return internal_id
        # The C library also does some crazy stuff with what might be the ns_status array

    def get_node_set_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the node set with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(NODESET, obj_id)

    def get_side_set_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the side set with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(SIDESET, obj_id)

    def get_elem_block_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the elem block with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(ELEMBLOCK, obj_id)

    ############################
    # Variables and time steps #
    ############################

    def get_all_times(self):
        &#34;&#34;&#34;Returns an array of all time values from all time steps from this database.&#34;&#34;&#34;
        try:
            result = self.data.variables[VAR_TIME_WHOLE][:]
        except KeyError:
            raise KeyError(&#34;Could not retrieve time steps from database!&#34;)
        return result

    def get_time(self, time_step):
        &#34;&#34;&#34;
        Returns the time value for specified time step.

        Time steps are 1-indexed. The first time step is at 1, and the last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if time_step &lt;= 0 or time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(time_step))
        return self.get_all_times()[time_step - 1]

    def get_nodal_var_at_time(self, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the nodal variable with given index at specified time step.

        Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_nodal_var_across_times(time_step, time_step, var_index)[0]

    def get_nodal_var_across_times(self, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the nodal variable with given index between specified time steps (inclusive).

        Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_partial_nodal_var_across_times(start_time_step, end_time_step, var_index, 1, self.num_nodes)

    def get_partial_nodal_var_across_times(self, start_time_step, end_time_step, var_index, start_index, count):
        &#34;&#34;&#34;
        Returns partial values of a nodal variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if self.num_nodes == 0:
            return [[]]
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Start time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        if var_index &lt;= 0 or var_index &gt; self.num_node_var:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        if start_index &lt;= 0:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if not self.large_model:
            # All vars stored in one variable
            try:
                # Do not subtract 1 from end (inclusive)
                result = self.data.variables[VAR_VALS_NOD_VAR_SMALL][
                         start_time_step - 1:end_time_step, var_index - 1, start_index - 1:start_index + count - 1]
            except KeyError:
                raise KeyError(&#34;Could not find the nodal variables in this database!&#34;)
        else:
            # Each var to its own variable
            try:
                result = self.data.variables[VAR_VALS_NOD_VAR_LARGE % var_index][start_time_step - 1:end_time_step, :]
            except KeyError:
                raise KeyError(&#34;Could not find nodal variable {} in this database!&#34;.format(var_index))
        return result

    def get_global_vars_at_time(self, time_step):
        &#34;&#34;&#34;
        Returns the values of the all global variables at specified time step.

        Time steps are 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_global_vars_across_times(time_step, time_step)[0]

    def get_global_vars_across_times(self, start_time_step, end_time_step):
        &#34;&#34;&#34;
        Returns the values of the all global variables between specified time steps (inclusive).

        Time steps are 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        try:
            # Do not subtract 1 from end (inclusive)
            result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, :]
        except KeyError:
            raise KeyError(&#34;Could not find global variables in this database!&#34;)
        return result

    def get_global_var_at_time(self, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the global variable with given index at specified time step.

        Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_global_var_across_times(time_step, time_step, var_index)[0]

    def get_global_var_across_times(self, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the global variable with given index between specified time steps (inclusive).

        Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        if var_index &lt;= 0 or var_index &gt; self.num_global_var:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        try:
            result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, var_index - 1]
        except KeyError:
            raise KeyError(&#34;Could not find global variables in this database!&#34;)
        return result

    def _int_get_partial_object_var_across_times(self, obj_type: ObjectType, internal_id, start_time_step,
                                                 end_time_step, var_index,
                                                 start_index, count):
        &#34;&#34;&#34;
        Returns partial values of an element block variable between specified time steps (inclusive).

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object this id refers to
        :param internal_id: INTERNAL (1-based) id
        :param start_time_step: start time (inclusive)
        :param end_time_step:  end time (inclusive)
        :param var_index: variable index (1-based)
        :param start_index: element start index (1-based)
        :param count: number of elements
        :return: 2d array storing the partial variable array at each time step
        &#34;&#34;&#34;

        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))

        if obj_type == ELEMBLOCK:
            varname = VAR_VALS_ELEM_VAR
            numvar = self.num_elem_block_var
        elif obj_type == NODESET:
            varname = VAR_VALS_NS_VAR
            numvar = self.num_node_set_var
        elif obj_type == SIDESET:
            varname = VAR_VALS_SS_VAR
            numvar = self.num_side_set_var
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))

        if var_index &lt;= 0 or var_index &gt; numvar:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        if start_index &lt;= 0:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            result = self.data.variables[varname % (var_index, internal_id)][
                     start_time_step - 1:end_time_step, start_index - 1:start_index + count - 1]
        except KeyError:
            raise KeyError(&#34;Could not find variables of type {} in this database!&#34;.format(obj_type))
        return result

    def get_elem_block_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the element block with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_elem_block_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the element block with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        # This method cannot simply call its partial version because we cannot know the number of elements to read
        #  without looking up the id first. This extra id lookup call is slow, so we get around it with a helper method.
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                                count):
        &#34;&#34;&#34;
        Returns partial values of an element block variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def get_node_set_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the node set with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_node_set_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the node set with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        size = self._int_get_node_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                              count):
        &#34;&#34;&#34;
        Returns partial values of a node set variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def get_side_set_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the side set with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_side_set_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the side set with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                              count):
        &#34;&#34;&#34;
        Returns partial values of a side set variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def _get_truth_table(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns the truth table for variables of a given object type.

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object
        :return: truth table
        &#34;&#34;&#34;
        if obj_type == ELEMBLOCK:
            tabname = VAR_ELEM_TAB
            valname = VAR_VALS_ELEM_VAR
            num_entity = self.num_elem_blk
            num_var = self.num_elem_block_var
        elif obj_type == NODESET:
            tabname = VAR_NS_TAB
            valname = VAR_VALS_NS_VAR
            num_entity = self.num_node_sets
            num_var = self.num_node_set_var
        elif obj_type == SIDESET:
            tabname = VAR_SS_TAB
            valname = VAR_VALS_SS_VAR
            num_entity = self.num_side_sets
            num_var = self.num_side_set_var
        else:
            raise ValueError(&#34;Invalid object type {}!&#34;.format(obj_type))
        if tabname in self.data.variables:
            result = self.data.variables[tabname][:]
        else:
            # we have to figure it out for ourselves
            result = numpy.zeros((num_entity, num_var), dtype=self.int)
            for e in range(num_entity):
                for v in range(num_var):
                    if valname % (v + 1, e + 1) in self.data.variables:
                        result[e, v] = 1
        return result

    def get_elem_block_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for element blocks.&#34;&#34;&#34;
        return self._get_truth_table(ELEMBLOCK)

    def get_node_set_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for node sets.&#34;&#34;&#34;
        return self._get_truth_table(NODESET)

    def get_side_set_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for side sets.&#34;&#34;&#34;
        return self._get_truth_table(SIDESET)

    def _get_var_names(self, var_type: VariableType):
        &#34;&#34;&#34;
        Returns a list of variable names for objects of a given type.

        :param var_type: the type of variable
        :return: a list of variable names
        &#34;&#34;&#34;
        if var_type == GLOBAL_VAR:
            varname = VAR_NAME_GLO_VAR
        elif var_type == NODAL_VAR:
            varname = VAR_NAME_NOD_VAR
        elif var_type == ELEMENTAL_VAR:
            varname = VAR_NAME_ELEM_VAR
        elif var_type == NODESET_VAR:
            varname = VAR_NAME_NS_VAR
        elif var_type == SIDESET_VAR:
            varname = VAR_NAME_SS_VAR
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(var_type))
        try:
            names = self.data.variables[varname][:]
        except KeyError:
            raise KeyError(&#34;No {} variable names stored in database!&#34;.format(var_type))
        result = numpy.empty([len(names)], self._MAX_NAME_LENGTH_T)
        for i in range(len(names)):
            result[i] = util.lineparse(names[i])
        return result

    def has_var_names(self, var_type: VariableType):
        &#34;&#34;&#34;
        .Test if this Exodus file has variable names for a variable type.

        :param var_type: GLOBAL_VAR, NODAL_VAR, ELEMENTAL_VAR, NODESET_VAR, or SIDESET_VAR from `constants`
        :return: True if this variable type has names defined, false otherwise
        &#34;&#34;&#34;
        if var_type == GLOBAL_VAR:
            varname = VAR_NAME_GLO_VAR
        elif var_type == NODAL_VAR:
            varname = VAR_NAME_NOD_VAR
        elif var_type == ELEMENTAL_VAR:
            varname = VAR_NAME_ELEM_VAR
        elif var_type == NODESET_VAR:
            varname = VAR_NAME_NS_VAR
        elif var_type == SIDESET_VAR:
            varname = VAR_NAME_SS_VAR
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(var_type))
        return varname in self.data.variables

    def get_global_var_names(self):
        &#34;&#34;&#34;Returns a list of all global variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(GLOBAL_VAR)

    def get_nodal_var_names(self):
        &#34;&#34;&#34;Returns a list of all nodal variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(NODAL_VAR)

    def get_elem_var_names(self):
        &#34;&#34;&#34;Returns a list of all element variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(ELEMENTAL_VAR)

    def get_node_set_var_names(self):
        &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(NODESET_VAR)

    def get_side_set_var_names(self):
        &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(SIDESET_VAR)

    def _get_var_name(self, var_type, index):
        &#34;&#34;&#34;Returns variable name of variable with given index of given object type.&#34;&#34;&#34;
        names = self._get_var_names(var_type)
        try:
            name = names[index - 1]
        except IndexError:
            raise IndexError(&#34;Variable index out of range. Got {}&#34;.format(index))
        return name

    def get_global_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the global variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(GLOBAL_VAR, index)

    def get_nodal_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the nodal variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(NODAL_VAR, index)

    def get_elem_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the element variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(ELEMENTAL_VAR, index)

    def get_node_set_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the node set variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(NODESET_VAR, index)

    def get_side_set_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the side set variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(SIDESET_VAR, index)

    ######################
    # Node and side sets #
    ######################

    def _int_get_partial_node_set(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the nodes contained in the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: node start index (1-based)
        :param count: number of nodes
        :return: array containing the selected part of the node set
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            set = self.data.variables[VAR_NODE_NS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve node set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_NODE_NS % internal_id))
        return set

    def _int_get_partial_node_set_df(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: node start index (1-based)
        :param count: number of nodes
        :return: array containing the selected part of the node set distribution factors list
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (&#39;dist_fact_ns%d&#39; % internal_id) in self.data.variables:
            set = self.data.variables[VAR_DF_NS % internal_id][start - 1:start + count - 1]
        else:
            warnings.warn(&#34;This database does not contain dist factors for node set {}&#34;.format(obj_id))
            set = []
        return set

    def _int_get_node_set_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of nodes, number of distribution factors)
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        try:
            num_entries = self.data.dimensions[DIM_NUM_NODE_NS % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of entries in node set with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_NODE_NS % internal_id))
        if (VAR_DF_NS % internal_id) in self.data.variables:
            num_df = num_entries
        else:
            num_df = 0
        return num_entries, num_df

    def get_node_set(self, identifier):
        &#34;&#34;&#34;Returns an array of the nodes contained in the node set with given ID.&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_node_set(identifier)

        internal_id = self._lookup_id(NODESET, identifier)
        size = self._int_get_node_set_params(identifier, internal_id)[0]
        return self._int_get_partial_node_set(identifier, internal_id, 1, size)

    def get_partial_node_set(self, identifier, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the nodes contained in the node set with given ID.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_partial_node_set(identifier, start, count)

        internal_id = self._lookup_id(NODESET, identifier)
        return self._int_get_partial_node_set(identifier, internal_id, start, count)

    def get_node_set_df(self, obj_id):
        &#34;&#34;&#34;Returns an array containing the distribution factors in the node set with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        size = self._int_get_node_set_params(obj_id, internal_id)[1]
        return self._int_get_partial_node_set_df(obj_id, internal_id, 1, size)

    def get_partial_node_set_df(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the node set with given ID.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_partial_node_set_df(obj_id, internal_id, start, count)

    def get_node_set_params(self, obj_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the node set with given ID.

        Returned tuple is of format (number of nodes, number of distribution factors).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_node_set_params(obj_id, internal_id)

    def _int_get_partial_side_set(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns tuple containing a subset of the elements and side contained in the side set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: tuple containing the selected part of the side set of format: (elements, corresponding sides)
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            elmset = self.data.variables[VAR_ELEM_SS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(
                &#34;Failed to retrieve elements of side set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_ELEM_SS % internal_id))
        try:
            sset = self.data.variables[VAR_SIDE_SS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(
                &#34;Failed to retrieve sides of side set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_SIDE_SS % internal_id))
        return elmset, sset

    def _int_get_partial_side_set_df(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the side set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the side set distribution factors list
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (VAR_DF_SS % internal_id) in self.data.variables:
            set = self.data.variables[VAR_DF_SS % internal_id][start - 1:start + count - 1]
        else:
            warnings.warn(&#34;This database does not contain dist factors for side set {}&#34;.format(obj_id))
            set = []
        return set

    def _int_get_side_set_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the side set with given ID.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of elements, number of distribution factors)
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        try:
            num_entries = self.data.dimensions[DIM_NUM_SIDE_SS % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of entries in side set with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_SIDE_SS % internal_id))
        if DIM_NUM_DF_SS % internal_id in self.data.dimensions:
            num_df = self.data.dimensions[DIM_NUM_DF_SS % internal_id].size
        else:
            num_df = 0
        return num_entries, num_df

    def get_side_set(self, obj_id):
        &#34;&#34;&#34;
        Returns tuple containing the elements and sides contained in the side set with given ID.

        Returned tuple is of format (elements in side set, sides in side set).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_side_set(obj_id, internal_id, 1, size)

    def get_side_set_node_count_list(self, obj_id):
        &#34;&#34;&#34;Returns array of number of nodes per side/face.&#34;&#34;&#34;
        # Adapted from ex_get_side_set_node_count.c
        internal_id = self._lookup_id(SIDESET, obj_id)
        num_eb = self.num_elem_blk
        ndim = self.num_dim
        num_ss_elem, _ = self._int_get_side_set_params(obj_id, internal_id)
        elem_list, side_list = self.get_side_set(obj_id)
        ss_elem_idx = numpy.argsort(elem_list)
        eb_id_map = self.get_elem_block_id_map()
        eb_params = []
        elem_ctr = 0
        for i in range(num_eb):
            id = eb_id_map[i]
            eb_params.append(self._int_get_elem_block_param_object(id, ndim))
            elem_ctr += eb_params[i].num_elem_in_blk
            eb_params[i].elem_ctr = elem_ctr
        node_count_list = numpy.empty(num_ss_elem, self.int)
        j = 0  # current elem block
        for ii in range(num_ss_elem):
            i = ss_elem_idx[ii]
            elem = elem_list[i]
            side = side_list[i] - 1  # 0 based side
            while j &lt; num_eb:
                if elem &lt;= eb_params[j].elem_ctr:
                    break
                else:
                    j += 1
            if j &gt;= num_eb:
                raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
            if side &gt;= eb_params[j].num_sides:
                raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                                 (side, eb_params[j].elem_type_str, obj_id))
            node_count_list[i] = eb_params[j].num_nodes_per_side[side]
        return node_count_list

    def get_side_set_node_list(self, obj_id):
        &#34;&#34;&#34;
        Returns array of nodes for this side set and the node count list.

        :return: (node list, node count list)
        &#34;&#34;&#34;
        # Adapted from ex_get_side_set_node_list.c.
        # I really really really hope this doesn&#39;t have errors in it
        internal_id = self._lookup_id(SIDESET, obj_id)
        num_eb = self.num_elem_blk
        num_elem = self.num_elem
        ndim = self.num_dim
        num_ss_elem, num_ss_df = self._int_get_side_set_params(obj_id, internal_id)
        elem_list, side_list = self.get_side_set(obj_id)
        ss_elem_idx = numpy.argsort(elem_list)
        eb_id_map = self.get_elem_block_id_map()
        eb_params = []
        elem_ctr = 0
        for i in range(num_eb):
            id = eb_id_map[i]
            eb_params.append(self._int_get_elem_block_param_object(id, ndim))
            elem_ctr += eb_params[i].num_elem_in_blk
            eb_params[i].elem_ctr = elem_ctr
        ss_param_idx = numpy.empty(num_ss_elem, int)  # ss element to eb param index
        ss_elem_node_idx = numpy.empty(num_ss_elem, int)  # ss element to node list index
        node_count_list = numpy.empty(num_ss_elem, self.int)
        node_ctr = 0
        j = 0  # current elem block
        for ii in range(num_ss_elem):
            i = ss_elem_idx[ii]
            elem = elem_list[i]
            side = side_list[i]
            while j &lt; num_eb:
                if eb_params[j].elem_type_val != NULL:
                    if elem &lt;= eb_params[j].elem_ctr:
                        break
                    else:
                        j += 1
            if j &gt;= num_eb:
                raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
            if side &gt;= eb_params[j].num_sides:
                raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                                 (side, eb_params[j].elem_type_str, obj_id))
            ss_param_idx[i] = j
            ss_elem_node_idx[i] = eb_params[j].num_nodes_per_side[side - 1]
            node_ctr += eb_params[j].num_nodes_per_side[side - 1]

        if num_ss_df &gt; 0 and num_ss_df != num_ss_elem:
            if node_ctr != num_ss_df:
                warnings.warn(&#34;Side set %d dist fact count (%d) does not match node list length (%d)! This may indicate&#34;
                              &#34; a corrupt database.&#34; % (obj_id, num_ss_df, node_ctr))

        for i in range(num_ss_elem):
            node_count_list[i] = ss_elem_node_idx[i]

        sum = 0
        for i in range(num_ss_elem):
            cnt = ss_elem_node_idx[i]
            ss_elem_node_idx[i] = sum
            sum += cnt

        node_list = numpy.empty(node_ctr, self.int)

        elem_ctr = 0
        connect = None
        for j in range(num_ss_elem):
            elem_idx = ss_elem_idx[j]
            elem = elem_list[elem_idx]
            side = side_list[elem_idx]
            param_idx = ss_param_idx[elem_idx]

            if elem &gt; elem_ctr:
                # We&#39;re doing this the C way because copying code from SEACAS saves development time
                connect = numpy.ndarray.flatten(self.get_elem_block_connectivity(eb_params[param_idx].elem_blk_id))
                elem_ctr = eb_params[param_idx].elem_ctr

            if connect is None:
                raise ValueError(&#34;connect is None in get_side_set_node_list. This is likely the result of an abnormal&#34;
                                 &#34; Exodus file.&#34;)

            elem_num = elem - 1
            elem_num_pos = elem_num - (eb_params[param_idx].elem_ctr - eb_params[param_idx].num_elem_in_blk)

            num_nodes_per_elem = eb_params[param_idx].num_nodes_per_elem
            connect_offset = num_nodes_per_elem * elem_num_pos
            side_num = side - 1
            node_pos = ss_elem_node_idx[elem_idx]

            if eb_params[param_idx].elem_type_val == CIRCLE or eb_params[param_idx].elem_type_val == SPHERE:
                node_list[node_pos] = connect[connect_offset]
            elif eb_params[param_idx].elem_type_val == TRUSS:
                node_list[node_pos] = connect[connect_offset + side_num]
            elif eb_params[param_idx].elem_type_val == BEAM:
                for i in range(num_nodes_per_elem):
                    node_list[node_pos + i] = connect[connect_offset + i]
            elif eb_params[param_idx].elem_type_val == TRIANGLE:
                if ndim == 2:
                    if side_num + 1 &lt; 1 or side_num + 1 &gt; 3:
                        raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                    node_list[node_pos] = connect[connect_offset + tri_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + tri_table[side_num][1] - 1]
                    if num_nodes_per_elem &gt; 3:
                        node_list[node_pos + 2] = connect[connect_offset + tri_table[side_num][2] - 1]
                elif ndim == 3:
                    if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                        raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                    node_list[node_pos] = connect[connect_offset + tri3_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + tri3_table[side_num][1] - 1]
                    if side_num + 1 &lt;= 2:
                        if num_nodes_per_elem == 3:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                        elif num_nodes_per_elem == 4:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            # This looks wrong, but it&#39;s what the C library does...
                            node_list[node_pos + 2] = connect[connect_offset + 4 - 1]
                        elif num_nodes_per_elem == 6:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                            node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                            node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                        elif num_nodes_per_elem == 7:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                            node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                            node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                            node_list[node_pos + 6] = connect[connect_offset + tri3_table[side_num][6] - 1]
                        else:
                            raise ValueError(&#34;%d is an unsupported number of nodes for triangle elements!&#34; %
                                             num_nodes_per_elem)
                    else:
                        if num_nodes_per_elem &gt; 3:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == QUAD:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                    raise ValueError(&#34;Invalid quad side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + quad_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + quad_table[side_num][1] - 1]
                if num_nodes_per_elem &gt; 5:
                    node_list[node_pos + 2] = connect[connect_offset + quad_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == SHELL:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                    raise ValueError(&#34;Invalid shell side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + shell_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + shell_table[side_num][1] - 1]
                if num_nodes_per_elem &gt; 2:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
                        node_list[node_pos + 3] = connect[connect_offset + shell_table[side_num][3] - 1]
                if num_nodes_per_elem == 8:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                    else:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
                if num_nodes_per_elem == 9:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + shell_table[side_num][8] - 1]
                    else:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == TETRA:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                    raise ValueError(&#34;Invalid tetra side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + tetra_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + tetra_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + tetra_table[side_num][2] - 1]
                if num_nodes_per_elem == 8:
                    node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
                elif num_nodes_per_elem &gt; 8:
                    node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + tetra_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + tetra_table[side_num][5] - 1]
            elif eb_params[param_idx].elem_type_val == WEDGE:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                    raise ValueError(&#34;Invalid wedge side number %d!&#34; % (side_num + 1))
                if num_nodes_per_elem == 6 or num_nodes_per_elem == 7:
                    node_list[node_pos + 0] = connect[connect_offset + wedge6_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge6_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge6_table[side_num][2] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 3] = connect[connect_offset + wedge6_table[side_num][3] - 1]
                elif num_nodes_per_elem == 15 or num_nodes_per_elem == 16:
                    node_list[node_pos + 0] = connect[connect_offset + wedge15_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge15_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge15_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge15_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge15_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge15_table[side_num][5] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 6] = connect[connect_offset + wedge15_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + wedge15_table[side_num][7] - 1]
                elif num_nodes_per_elem == 12:
                    node_list[node_pos + 0] = connect[connect_offset + wedge12_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge12_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge12_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge12_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge12_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge12_table[side_num][5] - 1]
                elif num_nodes_per_elem == 20:
                    node_list[node_pos + 0] = connect[connect_offset + wedge20_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge20_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge20_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge20_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge20_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge20_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + wedge20_table[side_num][6] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 7] = connect[connect_offset + wedge20_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge20_table[side_num][8] - 1]
                elif num_nodes_per_elem == 21:
                    node_list[node_pos + 0] = connect[connect_offset + wedge21_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge21_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge21_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge21_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge21_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge21_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + wedge21_table[side_num][6] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 7] = connect[connect_offset + wedge21_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge21_table[side_num][8] - 1]
                elif num_nodes_per_elem == 18:
                    node_list[node_pos + 0] = connect[connect_offset + wedge18_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge18_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge18_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge18_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge18_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge18_table[side_num][5] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 6] = connect[connect_offset + wedge18_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + wedge18_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge18_table[side_num][8] - 1]
            elif eb_params[param_idx].elem_type_val == PYRAMID:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                    raise ValueError(&#34;Invalid pyramid side number %d!&#34; % (side_num + 1))
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][0] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][1] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][2] - 1]
                node_pos += 1
                if pyramid_table[side_num][3] == 0:
                    pass  # this one even confuses the C library
                else:
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][3] - 1]
                    node_pos += 1
                if num_nodes_per_elem &gt; 5:
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][4] - 1]
                    node_pos += 1
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][5] - 1]
                    node_pos += 1
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][6] - 1]
                    node_pos += 1
                    if side_num == 4:
                        node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][7] - 1]
                        node_pos += 1
                        if num_nodes_per_elem &gt;= 14:
                            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                            node_pos += 1
                    else:
                        if num_nodes_per_elem &gt;= 18:
                            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                            node_pos += 1
            elif eb_params[param_idx].elem_type_val == HEX:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                    raise ValueError(&#34;Invalid hex side number %d!&#34; % (side_num + 1))
                if num_nodes_per_elem == 16:
                    node_list[node_pos + 0] = connect[connect_offset + hex16_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + hex16_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + hex16_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][3] - 1]
                    # I have no idea whats going on with these next two statements
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][4] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][5] - 1]
                    if side_num + 1 == 5 or side_num + 1 == 6:
                        # Also no idea about these ones
                        node_list[node_pos] = connect[connect_offset + hex16_table[side_num][6] - 1]
                        node_pos += 1
                        node_list[node_pos] = connect[connect_offset + hex16_table[side_num][7] - 1]
                        node_pos += 1
                else:
                    node_list[node_pos + 0] = connect[connect_offset + hex_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + hex_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + hex_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex_table[side_num][3] - 1]
                    if num_nodes_per_elem &gt; 12:
                        node_list[node_pos + 4] = connect[connect_offset + hex_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + hex_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + hex_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + hex_table[side_num][7] - 1]
                    if num_nodes_per_elem == 27:
                        node_list[node_pos + 8] = connect[connect_offset + hex_table[side_num][8] - 1]
            else:
                raise ValueError(&#34;%s is an unsupported element type.&#34; % eb_params[param_idx].elem_type_str)
        return node_list, node_count_list

    def get_partial_side_set(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns tuple containing a subset of the elements and sides contained in the side set with given ID.

        Arrays start at element number ``start`` (1-based) and contains ``count`` elements.
        Returned tuple is of format (elements in side set, sides in side set).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_side_set(obj_id, internal_id, start, count)

    def get_side_set_df(self, obj_id):
        &#34;&#34;&#34;Returns an array containing the distribution factors in the side set with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[1]
        return self._int_get_partial_side_set_df(obj_id, internal_id, 1, size)

    def get_partial_side_set_df(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the side set with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_side_set_df(obj_id, internal_id, start, count)

    def get_side_set_params(self, obj_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the side set with given ID.

        Returned tuple is of format (number of elements, number of distribution factors).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_side_set_params(obj_id, internal_id)

    ##################
    # Element blocks #
    ##################

    def _int_get_partial_elem_block_connectivity(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial connectivity list for the element block with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the connectivity list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (DIM_NUM_NOD_PER_EL % internal_id) in self.data.dimensions:
            num_node_entry = self.data.dimensions[DIM_NUM_NOD_PER_EL % internal_id].size
        else:
            num_node_entry = 0
        if num_node_entry &gt; 0:
            try:
                result = self.data.variables[VAR_CONNECT % internal_id][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve connectivity list of element block with id {} (&#39;{}&#39;)&#34;
                               .format(obj_id, VAR_CONNECT % internal_id))
        else:
            result = []
        return result

    def _int_get_elem_block_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the element block with given ID.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of elements, nodes per element, topology, number of attributes)
        &#34;&#34;&#34;
        # TODO this will be way faster with caching
        try:
            num_entries = self.data.dimensions[DIM_NUM_EL_IN_BLK % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of elements in element block with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_EL_IN_BLK % internal_id))
        if (DIM_NUM_NOD_PER_EL % internal_id) in self.data.dimensions:
            num_node_entry = self.data.dimensions[DIM_NUM_NOD_PER_EL % internal_id].size
        else:
            num_node_entry = 0
        try:
            if num_node_entry &gt; 0:
                connect = self.data.variables[VAR_CONNECT % internal_id]
                topology = connect.getncattr(ATTR_ELEM_TYPE)
            else:
                topology = None
        except KeyError:
            raise KeyError(&#34;Failed to retrieve connectivity list of element block with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, VAR_CONNECT % internal_id))
        if (DIM_NUM_ATT_IN_BLK % internal_id) in self.data.dimensions:
            num_att_blk = self.data.dimensions[DIM_NUM_ATT_IN_BLK % internal_id].size
        else:
            num_att_blk = 0
        return num_entries, num_node_entry, topology, num_att_blk

    def get_elem_block_connectivity(self, obj_id):
        &#34;&#34;&#34;Returns the connectivity list for the element block with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, 1, size)

    def get_partial_elem_block_connectivity(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial connectivity list for the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, start, count)

    def get_elem_block_params(self, obj_id) -&gt; Tuple[builtins.int, builtins.int, str, builtins.int]:
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the element block with given ID.

        Returned tuple is of format (number of elements, nodes per element, topology, number of attributes).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_elem_block_params(obj_id, internal_id)

    def _int_get_elem_block_param_object(self, obj_id, ndim) -&gt; ElemBlockParam:
        &#34;&#34;&#34;Returns parameters used to describe an elem block.&#34;&#34;&#34;
        # Adapted from ex_int_get_block_param.c
        # Used to get side set node count list
        num_el, nod_el, topo, num_att = self.get_elem_block_params(obj_id)
        topo = topo.upper()
        num_nod_side = numpy.zeros(6, builtins.int)
        if topo[:3] == CIRCLE[:3]:
            el_type = CIRCLE
            num_sides = 1
            num_nod_side[0] = 1
        elif topo[:3] == SPHERE[:3]:
            el_type = SPHERE
            num_sides = 1
            num_nod_side[0] = 1
        elif topo[:3] == QUAD[:3]:
            el_type = QUAD
            num_sides = 4
            if nod_el == 4 or nod_el == 5:
                num_nod_side[0] = 2
                num_nod_side[1] = 2
                num_nod_side[2] = 2
                num_nod_side[3] = 2
            elif nod_el == 9 or nod_el == 8:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
            elif nod_el == 12 or nod_el == 16:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TRIANGLE[:3]:
            el_type = TRIANGLE
            if ndim == 2:
                num_sides = 3
                if nod_el == 3 or nod_el == 4:
                    num_nod_side[0] = 2
                    num_nod_side[1] = 2
                    num_nod_side[2] = 2
                elif nod_el == 6 or nod_el == 7:
                    num_nod_side[0] = 3
                    num_nod_side[1] = 3
                    num_nod_side[2] = 3
                elif nod_el == 9 or nod_el == 13:
                    num_nod_side[0] = 4
                    num_nod_side[1] = 4
                    num_nod_side[2] = 4
                else:
                    raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
            elif ndim == 3:
                num_sides = 5
                if nod_el == 3 or nod_el == 4:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 2
                    num_nod_side[3] = 2
                    num_nod_side[4] = 2
                elif nod_el == 6 or nod_el == 7:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 3
                    num_nod_side[3] = 3
                    num_nod_side[4] = 3
                elif nod_el == 9 or nod_el == 13:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 4
                    num_nod_side[3] = 4
                    num_nod_side[4] = 4
                else:
                    raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == SHELL[:3]:
            el_type = SHELL
            if nod_el == 2:
                num_sides = 2
                num_nod_side[0] = 2
                num_nod_side[1] = 2
            elif nod_el == 4:
                num_sides = 6
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 2
                num_nod_side[3] = 2
                num_nod_side[4] = 2
                num_nod_side[5] = 2
            elif nod_el == 8 or nod_el == 9:
                num_sides = 6
                num_nod_side[0] = nod_el
                num_nod_side[1] = nod_el
                num_nod_side[2] = 3
                num_nod_side[3] = 3
                num_nod_side[4] = 3
                num_nod_side[5] = 3
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == HEX[:3]:
            el_type = HEX
            num_sides = 6
            if nod_el == 8 or nod_el == 9:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
                num_nod_side[4] = 4
                num_nod_side[5] = 4
            elif nod_el == 12:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 4
                num_nod_side[5] = 4
            elif nod_el == 16:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 8
                num_nod_side[5] = 8
            elif nod_el == 20:
                num_nod_side[0] = 8
                num_nod_side[1] = 8
                num_nod_side[2] = 8
                num_nod_side[3] = 8
                num_nod_side[4] = 8
                num_nod_side[5] = 8
            elif nod_el == 27:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 9
                num_nod_side[4] = 9
                num_nod_side[5] = 9
            elif nod_el == 32:
                num_nod_side[0] = 12
                num_nod_side[1] = 12
                num_nod_side[2] = 12
                num_nod_side[3] = 12
                num_nod_side[4] = 12
                num_nod_side[5] = 12
            elif nod_el == 64:
                num_nod_side[0] = 16
                num_nod_side[1] = 16
                num_nod_side[2] = 16
                num_nod_side[3] = 16
                num_nod_side[4] = 16
                num_nod_side[5] = 16
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TETRA[:3]:
            el_type = TETRA
            num_sides = 4
            if nod_el == 4 or nod_el == 5:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
            elif nod_el == 8:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
            elif nod_el == 10 or nod_el == 11:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
            elif nod_el == 14 or nod_el == 15:
                num_nod_side[0] = 7
                num_nod_side[1] = 7
                num_nod_side[2] = 7
                num_nod_side[3] = 7
            elif nod_el == 16:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 9
            elif nod_el == 40:
                num_nod_side[0] = 13
                num_nod_side[1] = 13
                num_nod_side[2] = 13
                num_nod_side[3] = 13
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == WEDGE[:3]:
            el_type = WEDGE
            num_sides = 5
            if nod_el == 6:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 3
                num_nod_side[4] = 3
            elif nod_el == 12:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 15 or nod_el == 16:
                num_nod_side[0] = 8
                num_nod_side[1] = 8
                num_nod_side[2] = 8
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 18:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 20 or nod_el == 21:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 7
                num_nod_side[4] = 7
            elif nod_el == 24:
                num_nod_side[0] = 12
                num_nod_side[1] = 12
                num_nod_side[2] = 12
                num_nod_side[3] = 9
                num_nod_side[4] = 9
            elif nod_el == 52:
                num_nod_side[0] = 16
                num_nod_side[1] = 16
                num_nod_side[2] = 16
                num_nod_side[3] = 13
                num_nod_side[4] = 13
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == PYRAMID[:3]:
            el_type = PYRAMID
            num_sides = 5
            if nod_el == 5:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
                num_nod_side[4] = 4
            elif nod_el == 13:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 8
            elif nod_el == 14:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 9
            elif nod_el == 18 or nod_el == 19:
                num_nod_side[0] = 7
                num_nod_side[1] = 7
                num_nod_side[2] = 7
                num_nod_side[3] = 7
                num_nod_side[4] = 9
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == BEAM[:3]:
            el_type = BEAM
            num_sides = 2
            if nod_el == 2:
                num_nod_side[0] = 2
                num_nod_side[1] = 2
            elif nod_el == 3:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
            elif nod_el == 4:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TRUSS[:3] or topo[:3] == BAR[:3] or topo[:3] == EDGE[:3]:
            el_type = TRUSS
            num_sides = 2
            if nod_el == 2 or nod_el == 3:
                num_nod_side[0] = 1
                num_nod_side[1] = 1
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        # Special case for null elements
        elif topo[:3] == NULL[:3]:
            el_type = NULL
            num_sides = 0
            num_nod_side[0] = 0
            num_el = 0
        else:
            el_type = UNKNOWN
            num_sides = 0
            num_nod_side[0] = 0
        return ElemBlockParam(topo, obj_id, num_el, nod_el, num_sides, num_nod_side, num_att, 0, el_type)

    #########
    # Names #
    #########

    def _get_set_block_names(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns a list of names for objects of a given type.
        :param obj_type: type of object
        :return: a list of names
        &#34;&#34;&#34;
        names = []
        if obj_type == NODESET:
            try:
                names = self.data.variables[VAR_NS_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain node set names.&#34;)
        elif obj_type == SIDESET:
            try:
                names = self.data.variables[VAR_SS_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain side set names.&#34;)
        elif obj_type == ELEMBLOCK:
            try:
                names = self.data.variables[VAR_EB_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain element block names.&#34;)
        else:
            raise ValueError(&#34;{} is not a valid set/block type!&#34;.format(obj_type))
        result = numpy.empty([len(names)], self._MAX_NAME_LENGTH_T)
        for i in range(len(names)):
            result[i] = util.lineparse(names[i])
        return result

    def get_elem_block_names(self):
        &#34;&#34;&#34;Returns an array containing the names of element blocks in this database.&#34;&#34;&#34;
        return self._get_set_block_names(ELEMBLOCK)

    def get_elem_block_name(self, obj_id):
        &#34;&#34;&#34;Returns the name of the given element block.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        names = self._get_set_block_names(ELEMBLOCK)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    def get_node_set_names(self):
        &#34;&#34;&#34;Returns an array containing the names of node sets in this database.&#34;&#34;&#34;
        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            return self.ledger.get_node_set_names()
        return self._get_set_block_names(NODESET)

    def get_node_set_name(self, identifier):
        &#34;&#34;&#34;Returns the name of the given node set.&#34;&#34;&#34;
        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            return self.ledger.get_node_set_name(identifier)

        internal_id = self._lookup_id(NODESET, identifier)
        names = self._get_set_block_names(NODESET)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    def get_side_set_names(self):
        &#34;&#34;&#34;Returns an array containing the names of side sets in this database.&#34;&#34;&#34;
        return self._get_set_block_names(SIDESET)

    def get_side_set_name(self, obj_id):
        &#34;&#34;&#34;Returns the name of the given side set.&#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        names = self._get_set_block_names(SIDESET)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    ######################
    # Element Attributes #
    ######################

    def _int_get_num_elem_attrib(self, internal_id):
        &#34;&#34;&#34;
        Returns the number of attributes in the element block with given internal ID.

        FOR INTERNAL USE ONLY!
        &#34;&#34;&#34;
        # Some databases don&#39;t have attributes
        if (DIM_NUM_ATT_IN_BLK % internal_id) in self.data.dimensions:
            num = self.data.dimensions[DIM_NUM_ATT_IN_BLK % internal_id].size
        else:
            # No need to warn. If there are no attributes, the number is 0...
            num = 0
        return num

    def _int_get_partial_elem_attrib(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial list of all attributes for the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the attribute list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        varname = VAR_ELEM_ATTRIB % internal_id
        if varname in self.data.variables:
            result = self.data.variables[varname][start - 1:start + count - 1, :]
        else:
            result = []
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        return result

    def _int_get_partial_one_elem_attrib(self, obj_id, internal_id, attrib_index, start, count):
        &#34;&#34;&#34;
        Returns a partial list of one attribute for the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param attrib_index: attribute index (1-based)
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the attribute list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        num_attrib = self._int_get_num_elem_attrib(internal_id)
        if num_attrib &gt; 0:  # faster to check this than if the variable exists like in the function above this one
            if attrib_index &lt; 1 or attrib_index &gt; num_attrib:
                raise ValueError(&#34;Attribute index out of range. Got {}&#34;.format(attrib_index))
            result = self.data.variables[VAR_ELEM_ATTRIB % internal_id][start - 1:start + count - 1, attrib_index - 1]
        else:
            result = []
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        return result

    def get_partial_one_elem_attrib(self, obj_id, attrib_index, start, count):
        &#34;&#34;&#34;
        Returns a partial list of one attribute for the specified elements in the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, start, count)

    def get_one_elem_attrib(self, obj_id, attrib_index):
        &#34;&#34;&#34;
        Returns a list of one attribute for each element in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, 1, size)

    def get_elem_attrib(self, obj_id):
        &#34;&#34;&#34;
        Returns a list of all attributes for each element in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_elem_attrib(obj_id, internal_id, 1, size)

    def get_partial_elem_attrib(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial list of all attributes for the specified elements in the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_elem_attrib(obj_id, internal_id, start, count)

    def get_elem_attrib_names(self, obj_id):
        &#34;&#34;&#34;
        Returns a list of the names of attributes in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes or attribute names.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        num_attrib = self._int_get_num_elem_attrib(internal_id)
        result = []
        if num_attrib == 0:
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        else:
            varname = VAR_ELEM_ATTRIB_NAME % internal_id
            # Older datasets don&#39;t have attribute names
            if varname in self.data.variables:
                names = self.data.variables[varname][:]
                result = util.arrparse(names, len(names), self._MAX_NAME_LENGTH_T)
            else:
                warnings.warn(&#34;Attributes of element block {} have no names.&#34;.format(obj_id))
        return result

    def get_num_elem_attrib(self, obj_id):
        &#34;&#34;&#34;Returns the number of attributes in the element block with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_num_elem_attrib(internal_id)

    #####################
    # Object properties #
    #####################

    # This method contains a general algorithm for counting the number of properties an object has.
    # This is used by the num_*_prop properties which are in turn used by _get_object_property_names
    def _get_num_object_properties(self, varname):
        &#34;&#34;&#34;
        Returns the number of properties an object has.

        :param varname: the netCDF variable name of the property. (&#34;xx_prop_%d&#34;) where xx is ns, ss, or eb
        :return: number of properties
        &#34;&#34;&#34;
        # loop over the prop variables and count how many there are
        n = 0
        while True:
            if varname % (n + 1) in self.data.variables:
                n += 1
            else:
                break
        return n

    def _get_object_property(self, obj_type: ObjectType, obj_id, name):
        &#34;&#34;&#34;
        Returns the value of a specific object&#39;s property.

        :param obj_type: type of object this id refers to
        :param obj_id: EXTERNAL (user-defined) id
        :param name: name of the property
        :return: value of the property for the specified object
        &#34;&#34;&#34;
        internal_id = self._lookup_id(obj_type, obj_id)
        prop = self._get_object_property_array(obj_type, name)
        # We don&#39;t want to index into prop if it&#39;s empty
        if len(prop) &gt; 0:
            return prop[internal_id - 1]
        else:
            return None

    def get_node_set_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the node set with the given ID.&#34;&#34;&#34;
        return self._get_object_property(NODESET, obj_id, name)

    def get_side_set_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the side set with the given ID.&#34;&#34;&#34;
        return self._get_object_property(SIDESET, obj_id, name)

    def get_elem_block_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the element block with the given ID.&#34;&#34;&#34;
        return self._get_object_property(ELEMBLOCK, obj_id, name)

    def _get_object_property_array(self, obj_type: ObjectType, name):
        &#34;&#34;&#34;
        Returns a list containing all the values of a particular property for objects of a given type.

        :param obj_type: type of object this id refers to
        :param name: name of the property
        :return: array containing values of the property for objects of the given type
        &#34;&#34;&#34;
        if obj_type == NODESET:
            varname = VAR_NS_PROP
        elif obj_type == SIDESET:
            varname = VAR_SS_PROP
        elif obj_type == ELEMBLOCK:
            varname = VAR_EB_PROP
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))
        prop = []
        # Search for the property for the right name
        # We don&#39;t use a for loop over the number of props because that would cost a second loop over the props
        n = 1
        while True:
            if varname % n in self.data.variables:
                propname = self.data.variables[varname % n].getncattr(ATTR_NAME)
                if propname == name:
                    # we&#39;ve found our property
                    prop = self.data.variables[varname % n][:]
                    break
                else:
                    # check next property
                    n += 1
                    continue
            else:
                # &#34;xx_prop_n&#34; doesn&#39;t exist. name doesn&#39;t exist in file
                warnings.warn(&#34;Property {} does not exist!&#34;.format(name))
                break
        return prop

    def get_node_set_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all node sets.&#34;&#34;&#34;
        return self._get_object_property_array(NODESET, name)

    def get_side_set_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all side sets.&#34;&#34;&#34;
        return self._get_object_property_array(SIDESET, name)

    def get_elem_block_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all element blocks.&#34;&#34;&#34;
        return self._get_object_property_array(ELEMBLOCK, name)

    def _get_object_property_names(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns a list containing the names of properties defined for objects of a given type.

        :param obj_type: type of object
        :return: array of property names
        &#34;&#34;&#34;
        if obj_type == NODESET:
            varname = VAR_NS_PROP
            num_props = self.num_node_set_prop
        elif obj_type == SIDESET:
            varname = VAR_SS_PROP
            num_props = self.num_side_set_prop
        elif obj_type == ELEMBLOCK:
            varname = VAR_EB_PROP
            num_props = self.num_elem_block_prop
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))
        # num_props = self._get_num_object_properties(varname)
        result = numpy.empty([num_props], self._MAX_NAME_LENGTH_T)
        for n in range(num_props):
            result[n] = self.data.variables[varname % (n + 1)].getncattr(ATTR_NAME)
        return result

    def get_node_set_property_names(self):
        &#34;&#34;&#34;Returns a list of node set property names.&#34;&#34;&#34;
        return self._get_object_property_names(NODESET)

    def get_side_set_property_names(self):
        &#34;&#34;&#34;Returns a list of side set property names.&#34;&#34;&#34;
        return self._get_object_property_names(SIDESET)

    def get_elem_block_property_names(self):
        &#34;&#34;&#34;Returns a list of element block property names.&#34;&#34;&#34;
        return self._get_object_property_names(ELEMBLOCK)

    ###############
    # Coordinates #
    ###############

    def get_coords(self):
        &#34;&#34;&#34;Returns a multidimensional array containing the coordinates of all nodes.&#34;&#34;&#34;
        # Technically this incurs an extra call to num_nodes, but the reduced complexity is worth it
        return self.get_partial_coords(1, self.num_nodes)

    def get_partial_coords(self, start, count):
        &#34;&#34;&#34;
        Returns a multidimensional array containing the coordinates of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][:, start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coordx = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
            if dim_cnt &gt; 1:
                try:
                    coordy = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
                except KeyError:
                    raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
                if dim_cnt &gt; 2:
                    try:
                        coordz = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
                    except KeyError:
                        raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
                    coord = numpy.array([coordx, coordy, coordz])
                else:
                    coord = numpy.array([coordx, coordy])
            else:
                coord = coordx
        return coord

    def get_coord_x(self):
        &#34;&#34;&#34;Returns an array containing the x coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_x(1, self.num_nodes)

    def get_partial_coord_x(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the x coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        num_nodes = self.num_nodes
        if num_nodes == 0:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][0][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
        return coord

    def get_coord_y(self):
        &#34;&#34;&#34;Returns an array containing the y coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_y(1, self.num_nodes)

    def get_partial_coord_y(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the y coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0 or dim_cnt &lt; 2:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][1][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
        return coord

    def get_coord_z(self):
        &#34;&#34;&#34;Returns an array containing the z coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_z(1, self.num_nodes)

    def get_partial_coord_z(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the z coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0 or dim_cnt &lt; 3:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][2][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
        return coord

    def get_coord_names(self):
        &#34;&#34;&#34;Returns an array containing the names of the coordinate axes in this database.&#34;&#34;&#34;
        dim_cnt = self.num_dim
        try:
            names = self.data.variables[VAR_COORD_NAMES]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve coordinate name array!&#34;)
        result = util.arrparse(names, dim_cnt, self._MAX_NAME_LENGTH_T)
        return result

    ################
    # File records #
    ################

    def get_info(self):
        &#34;&#34;&#34;Returns an array containing the info records stored in this database.&#34;&#34;&#34;
        num = self.num_info
        result = numpy.empty([num], Exodus._MAX_LINE_LENGTH_T)
        if num &gt; 0:
            try:
                infos = self.data.variables[VAR_INFO]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve info records from database!&#34;)
            for i in range(num):
                result[i] = util.lineparse(infos[i])
        return result

    def get_qa(self):
        &#34;&#34;&#34;Returns an n x 4 array containing the QA records stored in this database.&#34;&#34;&#34;
        num = self.num_qa
        result = numpy.empty([num, 4], Exodus._MAX_STR_LENGTH_T)
        if num &gt; 0:
            try:
                qas = self.data.variables[VAR_QA]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve qa records from database!&#34;)
            for i in range(num):
                for j in range(4):
                    result[i, j] = util.lineparse(qas[i, j])
        return result

    # endregion

    @property
    def time_steps(self):
        &#34;&#34;&#34;Returns list of the time steps, 0-indexed&#34;&#34;&#34;
        return [*range(self.num_time_steps)]

    def step_at_time(self, time):
        &#34;&#34;&#34;Given a float time value, return the corresponding time step&#34;&#34;&#34;
        for index, value in enumerate(self.get_all_times()):
            if value == time:
                return index
        return None

    def get_dimension(self, name):
        if name in self.data.dimensions:
            return self.data.dimensions[name].size
        else:
            raise RuntimeError(&#34;dimensions &#39;{}&#39; cannot be found!&#34;.format(name))

    def get_parameter(self, name):
        if name in self.data.ncattrs():
            return self.data.getncattr(name)
        else:
            raise RuntimeError(&#34;parameter &#39;{}&#39; cannot be found!&#34;.format(name))

    def close(self):
        self.data.close()

    def print_dimensions(self):
        for dim in self.data.dimensions.values():
            print(dim)

    def print_dimension_names(self):
        for dim in self.data.dimensions:
            print(dim)

    def print_variables(self):
        for v in self.data.variables.values():
            print(v, &#34;\n&#34;)

    def print_variable_names(self):
        for v in self.data.variables:
            print(v)

    def set_nodeset(self, node_set_id, node_ids):
        ndx = node_set_id - 1
        if &#34;ns_prop1&#34; in self.data.variables:
            ndx = numpy.where(self.data.variables[&#34;ns_prop1&#34;][:] == node_set_id)[0][0]
            ndx += 1

        key = &#34;node_ns&#34; + str(ndx)
        nodeset = self.data[key]

        if &#34;node_num_map&#34; in self.data.variables:
            indices = numpy.zeros(len(node_ids))
            i = 0
            for id in node_ids:
                ndx = numpy.where(self.data[&#34;node_num_map&#34;][:] == id)[0][0]
                indices[i] = ndx
                i += 1
            nodeset[:] = indices
            return
        nodeset[:] = node_ids

    def get_nodes_in_elblock(self, id):
        if &#34;node_num_map&#34; in self.data.variables:
            raise Exception(&#34;Using node num map&#34;)
        nodeids = self.data[&#34;connect&#34; + str(id)]
        # flatten it into 1d
        nodeids = nodeids[:].flatten()
        return nodeids

    def diff(self, other):
        # # Nodesets
        selfNS = self.num_node_sets
        otherNS = other.num_node_sets
        print(&#34;Self # Nodesets:\t{}&#34;.format(selfNS))
        print(&#34;Other # Nodesets:\t{}&#34;.format(otherNS))

        # # Sidesets
        selfSS = self.num_side_sets
        otherSS = other.num_side_sets
        print(&#34;\nSelf # Sidesets:\t{}&#34;.format(selfSS))
        print(&#34;Other # Sidesets:\t{}&#34;.format(otherSS))

        # # Nodes
        selfN = self.num_nodes
        otherN = other.num_nodes
        print(&#34;\nSelf # Nodes:\t\t{}&#34;.format(selfN))
        print(&#34;Other # Nodes:\t\t{}&#34;.format(otherN))

        # # Elements
        selfE = self.num_elem
        otherE = other.num_elem
        print(&#34;\nSelf # Elements:\t{}&#34;.format(selfE))
        print(&#34;Other # Elements:\t{}\n&#34;.format(otherE))

        # Length of output variables (nodal/elemental)

    def diff_nodeset(self, id, other, id2=None):
        &#34;&#34;&#34;
        Prints the overlap and difference between two nodesets
        :param id: the nodeset ID of the self Exodus object
        :param other: the other Exodus object to compare to
        :param id2: optional parameter specifying the nodeset ID of other Exodus object. Default to the first id.
        &#34;&#34;&#34;

        if other is None:
            raise ValueError(&#34;Other Exodus file is None&#34;)

        if id2 is None:
            id2 = id
        try:
            ns1 = self.get_node_set(id)
        except KeyError:
            raise KeyError(&#34;Self Exodus file does not contain nodeset with ID {}&#34;.format(id))

        try:
            ns2 = other.get_node_set(id2)
        except KeyError:
            raise KeyError(&#34;Other Exodus file does not contain nodeset with ID {}&#34;.format(id2))

        equivalent = numpy.array_equal(numpy.array(sorted(ns1.tolist())), numpy.array(sorted(ns2.tolist())))
        if equivalent:
            print(&#34;Self NS {} contains the same Node IDs as Other NS ID {}&#34;.format(id, id2))
        else:
            print(&#34;Self NS ID {} does NOT contain the same nodes as Other NS ID {}&#34;.format(id, id2))
            intersection = set(ns1) &amp; set(ns2)
            print(&#34;\tBoth nodesets share the following nodes:\n\t{}&#34;.format(sorted(list(intersection))))
            ns1_diff = sorted(list(set(ns1) - intersection))
            print(&#34;\tSelf NS ID {} also contains nodes:\n\t{}&#34;.format(id, ns1_diff))
            ns2_diff = sorted(list(set(ns2) - intersection))
            print(&#34;\tOther NS ID {} also contains nodes:\n\t{}\n&#34;.format(id2, ns2_diff))

    ################################################################
    #                                                              #
    #                        Write                                 #
    #                                                              #
    ################################################################

    def add_nodeset(self, node_ids, nodeset_id, nodeset_name=&#34;&#34;):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_nodeset(node_ids, nodeset_id, nodeset_name)

    def remove_nodeset(self, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_nodeset(identifier)

    def merge_nodeset(self, new_id, ns1, ns2, delete=True):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.merge_nodesets(new_id, ns1, ns2, delete)

    def add_node_to_nodeset(self, node_id, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_node_to_nodeset(node_id, identifier)

    def add_nodes_to_nodeset(self, node_ids, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_nodes_to_nodeset(node_ids, identifier)

    def remove_node_from_nodeset(self, node_id, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_node_from_nodeset(node_id, identifier)

    def remove_nodes_from_nodeset(self, node_ids, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_nodes_from_nodeset(node_ids, identifier)

    def add_sideset(self, elem_ids, side_ids, ss_id, ss_name, dist_fact=None, variables=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_sideset(elem_ids, side_ids, ss_id, ss_name, dist_fact, variables)

    def remove_sideset(self, ss_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_sideset(ss_id)


    def add_sides_to_sideset(self, elem_ids, side_ids, ss_id, dist_facts=None, variables=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_sides_to_sideset(elem_ids, side_ids, ss_id, dist_facts, variables)

    def remove_sides_from_sideset(self, elem_ids, side_ids, ss_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_sides_from_sideset(elem_ids, side_ids, ss_id)

    def split_sideset(self, old_ss, function, ss_id1, ss_id2, delete, ss_name1=&#34;&#34;, ss_name2=&#34;&#34;):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to split sideset&#34;)
        self.ledger.split_sideset(old_ss, function, ss_id1, ss_id2, delete, ss_name1, ss_name2)
    

    def add_element(self, block_id, nodelist):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        return self.ledger.add_element(block_id, nodelist)


    def remove_element(self, elem_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        return self.ledger.remove_element(elem_id)

    def skin_element_block(self, block_id, skin_id, skin_name):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
        self.ledger.skin_element_block(block_id, skin_id, skin_name)

    def skin(self, skin_id, skin_name):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
        self.ledger.skin(skin_id, skin_name)
        
    def write(self, path=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to write&#34;)
        elif self.mode == &#39;a&#39; and path is None:
            raise AttributeError(&#34;Must specify a new path when in append mode&#34;)
        elif self.mode == &#39;w&#39; and path is not None:
            raise AttributeError(&#34;Do not specify a new path in write mode. Initialization path will be used&#34;)
        self.ledger.write(path)


# TODO some functions return numpy arrays, some return Python lists. Should be consistently one or the other.
# TODO you should be able to select variables by name as well as id!
#  that&#39;s what Sandia told us to do originally!
#  Same goes for other data types!


if __name__ == &#34;__main__&#34;:
    ...</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exodus.ElemBlockParam"><code class="flex name class">
<span>class <span class="ident">ElemBlockParam</span></span>
<span>(</span><span>elem_type_str: str, elem_blk_id: numpy.int64, num_elem_in_blk: numpy.int64, num_nodes_per_elem: int, num_sides: int, num_nodes_per_side: numpy.ndarray, num_attr: int, elem_ctr: numpy.int64, elem_type_val: constants.ElementTopography)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores data used to create a side set node count list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ElemBlockParam:
    &#34;&#34;&#34;Stores data used to create a side set node count list.&#34;&#34;&#34;
    # Adapted from exodusII_int.h on SEACAS
    elem_type_str: str
    elem_blk_id: numpy.int64
    num_elem_in_blk: numpy.int64
    num_nodes_per_elem: int
    num_sides: int
    num_nodes_per_side: numpy.ndarray
    num_attr: int
    elem_ctr: numpy.int64
    elem_type_val: ElementTopography</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="exodus.ElemBlockParam.elem_blk_id"><code class="name">var <span class="ident">elem_blk_id</span> : numpy.int64</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.elem_ctr"><code class="name">var <span class="ident">elem_ctr</span> : numpy.int64</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.elem_type_str"><code class="name">var <span class="ident">elem_type_str</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.elem_type_val"><code class="name">var <span class="ident">elem_type_val</span> : constants.ElementTopography</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.num_attr"><code class="name">var <span class="ident">num_attr</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.num_elem_in_blk"><code class="name">var <span class="ident">num_elem_in_blk</span> : numpy.int64</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.num_nodes_per_elem"><code class="name">var <span class="ident">num_nodes_per_elem</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.num_nodes_per_side"><code class="name">var <span class="ident">num_nodes_per_side</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exodus.ElemBlockParam.num_sides"><code class="name">var <span class="ident">num_sides</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exodus.Exodus"><code class="flex name class">
<span>class <span class="ident">Exodus</span></span>
<span>(</span><span>path, mode, shared=False, format='EX_NETCDF4', word_size=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exodus:
    _FORMAT_MAP = {&#39;EX_NETCDF4&#39;: &#39;NETCDF4&#39;,
                   &#39;EX_LARGE_MODEL&#39;: &#39;NETCDF3_64BIT_OFFSET&#39;,
                   &#39;EX_NORMAL_MODEL&#39;: &#39;NETCDF3_CLASSIC&#39;,
                   &#39;EX_64BIT_DATA&#39;: &#39;NETCDF3_64BIT_DATA&#39;}
    # Default values
    _MAX_STR_LENGTH = 32
    _MAX_STR_LENGTH_T = &#39;U32&#39;
    _MAX_NAME_LENGTH = 32
    _MAX_LINE_LENGTH = 80
    _MAX_LINE_LENGTH_T = &#39;U80&#39;
    _EXODUS_VERSION = 7.22

    # Should creating a new file (mode &#39;w&#39;) be a function on its own?
    def __init__(self, path, mode, shared=False, format=&#39;EX_NETCDF4&#39;, word_size=4):
        # clobber and format and word_size only apply to mode w
        if mode not in [&#39;r&#39;, &#39;w&#39;, &#39;a&#39;]:
            raise ValueError(&#34;mode must be &#39;w&#39;, &#39;r&#39;, or &#39;a&#39;, got &#39;{}&#39;&#34;.format(mode))
        if format not in Exodus._FORMAT_MAP.keys():
            raise ValueError(&#34;invalid file format: &#39;{}&#39;&#34;.format(format))
        if word_size not in [4, 8]:
            raise ValueError(&#34;word_size must be 4 or 8 bytes, {} is not supported&#34;.format(word_size))
        nc_format = Exodus._FORMAT_MAP[format]

        self.mode = mode
        self.path = path

        # file should never actually be opened in append mode
        # if append mode is specified, open file in read mode and write out changes to separate file
        if mode == &#39;a&#39;:
            mode = &#39;r&#39;

        # Sets shared mode if the user asked for it. I have no idea what this does :)
        if shared:
            smode = mode + &#39;s&#39;
        else:
            smode = mode
        try:
            self.data = nc.Dataset(path, smode, clobber=False, format=nc_format)
        except FileNotFoundError:
            raise FileNotFoundError(&#34;file &#39;{}&#39; does not exist&#34;.format(path)) from None
        except PermissionError:
            raise PermissionError(&#34;You do not have access to &#39;{}&#39;&#34;.format(path)) from None
        # TODO this can actually hide some errors which is bad. This check should be done explicitly
        except OSError:
            raise OSError(&#34;file &#39;{}&#39; already exists&#34;.format(path)) from None



        if self.mode == &#39;w&#39;:
            # This is important according to ex_open.c
            self.data.set_fill_off()

        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            self.ledger = Ledger(self)

        # save path variable for future use
        self.path = path

        # We will read a bunch of data here to make sure it exists and warn the user if they might want to fix their
        # file. We don&#39;t save anything to memory so that if our data updates we don&#39;t have to update it in memory too.
        # This is the same practice used in the C library so its probably a good idea.

        # Initialize all the important parameters
        if mode == &#39;w&#39;:
            self.data.setncattr(&#39;title&#39;, &#39;Untitled database&#39;)
            self.data.createDimension(&#39;len_string&#39;, Exodus._MAX_STR_LENGTH + 1)
            self.data.createDimension(&#39;len_name&#39;, Exodus._MAX_NAME_LENGTH + 1)
            self.data.createDimension(&#39;len_line&#39;, Exodus._MAX_LINE_LENGTH + 1)
            self.data.setncattr(&#39;maximum_name_length&#39;, Exodus._MAX_NAME_LENGTH)
            self.data.setncattr(&#39;version&#39;, Exodus._EXODUS_VERSION)
            self.data.setncattr(&#39;api_version&#39;, Exodus._EXODUS_VERSION)
            self.data.setncattr(&#39;floating_point_word_size&#39;, word_size)
            file_size = 0
            if nc_format == &#39;NETCDF3_64BIT_OFFSET&#39;:
                file_size = 1
            self.data.setncattr(&#39;file_size&#39;, file_size)
            int64bit_status = 0
            if nc_format == &#39;NETCDF3_64BIT_DATA&#39;:
                int64bit_status = 1
            self.data.setncattr(&#39;int64_status&#39;, int64bit_status)

        # TODO Uncomment these later
        #  The C library doesn&#39;t seem to care if the file is in read or modify mode when it does this
        # Add this if it doesn&#39;t exist (value of 33)
        # if &#39;len_name&#39; not in self.data.dimensions:
        #     warnings.warn(&#34;&#39;len_name&#39; dimension is missing!&#34;)

        # Add this if it doesn&#39;t exist (value of 32)
        # if &#39;maximum_name_length&#39; not in self.data.ncattrs():
        #     warnings.warn(&#34;&#39;maximum_name_length&#39; attribute is missing!&#34;)

        # Check version compatibility
        ver = self.version
        if ver &lt; 2.0:
            raise RuntimeError(
                &#34;Unsupported file version {:.2f}! Only versions &gt;2.0 are supported.&#34;.format(ver))

        # Read word size stored in file
        ws = self.word_size
        if ws == 4:
            self._float = numpy.float32
        elif ws == 8:
            self._float = numpy.float64
        else:
            raise ValueError(&#34;file contains a word size of {} which is not supported&#34;.format(ws))

        if self.int64_status == 0:
            self._int = numpy.int32
        else:
            self._int = numpy.int64

        # important for storing names in numpy arrays
        self._MAX_NAME_LENGTH_T = &#39;U%s&#39; % self.max_allowed_name_length

    def to_float(self, n):
        &#34;&#34;&#34;Returns ``n`` converted to the floating-point type stored in the database.&#34;&#34;&#34;
        # Convert a number to the floating point type the database is using
        return self._float(n)

    def to_int(self, n):
        &#34;&#34;&#34;Returns ``n`` converted to the integer type stored in the database.&#34;&#34;&#34;
        # Convert a number to the integer type the database is using
        return self._int(n)

    @property
    def float(self):
        &#34;&#34;&#34;The floating-point type stored in the database.&#34;&#34;&#34;
        # Returns floating point type of floating point numbers stored in the database
        # You may use whatever crazy types you want while coding, but convert them before storing them in the DB
        return self._float

    @property
    def int(self):
        &#34;&#34;&#34;The integer type stored in the database.&#34;&#34;&#34;
        # Returns integer type of integers stored in the database
        return self._int

    ########################################################################
    #                                                                      #
    #                        Data File Utilities                           #
    #                                                                      #
    ########################################################################

    # GLOBAL PARAMETERS AND MODEL DEFINITION

    # region Properties

    # TODO perhaps in-place properties like these could have property setters as well

    # TODO it would be nice to have the return values cached for these so they execute faster and act more like
    #  properties and less like small functions. This will require some write integration.

    @property
    def title(self):
        &#34;&#34;&#34;The database title.&#34;&#34;&#34;
        try:
            return self.data.getncattr(ATT_TITLE)
        except AttributeError:
            AttributeError(&#34;Database title could not be found&#34;)

    @property
    def max_allowed_name_length(self):
        &#34;&#34;&#34;The maximum allowed length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
        max_name_len = Exodus._MAX_NAME_LENGTH
        if DIM_NAME_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra null character is added for C reasons
            max_name_len = self.data.dimensions[DIM_NAME_LENGTH].size - 1
        return max_name_len

    @property
    def max_used_name_length(self):
        &#34;&#34;&#34;The maximum used length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
        # 32 is the default size consistent with other databases
        max_used_name_len = 32
        if ATT_MAX_NAME_LENGTH in self.data.ncattrs():
            # The length does not include the added null character from C
            max_used_name_len = self.data.getncattr(ATT_MAX_NAME_LENGTH)
        return max_used_name_len

    @property
    def max_string_length(self):
        &#34;&#34;&#34;Maximum QA record string length.&#34;&#34;&#34;
        # See ex_put_qa.c @ line 119. This record is created and used when adding QA records
        max_str_len = Exodus._MAX_STR_LENGTH
        if DIM_STRING_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra character is added for C reasons
            max_str_len = self.data.dimensions[DIM_STRING_LENGTH].size - 1
        return max_str_len

    @property
    def max_line_length(self):
        &#34;&#34;&#34;Maximum info record line length.&#34;&#34;&#34;
        # See ex_put_info.c @ line 121. This record is created and used when adding info records
        max_line_len = Exodus._MAX_LINE_LENGTH
        if DIM_LINE_LENGTH in self.data.dimensions:
            # Subtract 1 because in C an extra character is added for C reasons
            max_line_len = self.data.dimensions[DIM_LINE_LENGTH].size - 1
        return max_line_len

    @property
    def api_version(self):
        &#34;&#34;&#34;The Exodus API version this database was built with.&#34;&#34;&#34;
        try:
            result = self.data.getncattr(ATT_API_VER)
        except AttributeError:
            # Try the old way of spelling it
            try:
                result = self.data.getncattr(ATT_API_VER_OLD)
            except AttributeError:
                raise AttributeError(&#34;Exodus API version could not be found&#34;)
        return result

    @property
    def version(self):
        &#34;&#34;&#34;The Exodus version this database uses.&#34;&#34;&#34;
        try:
            return self.data.getncattr(ATT_VERSION)
        except AttributeError:
            raise AttributeError(&#34;Exodus database version could not be found&#34;)

    @property
    def large_model(self):
        &#34;&#34;&#34;
        Describes how coordinates are stored in this database.

        If true: nodal coordinates and variables are stored in separate x, y, z variables.
        If false: nodal coordinates and variables are stored in a single variable.

        :return: 1 if stored separately (large), 0 if stored in a blob
        &#34;&#34;&#34;
        # According to a comment in ex_utils.c @ line 1614
        # &#34;Basically, the difference is whether the coordinates and nodal variables are stored in a blob (xyz components
        # together) or as a variable per component per nodal_variable.&#34;
        # This is important for coordinate getter functions
        if ATT_FILE_SIZE in self.data.ncattrs():
            return self.data.getncattr(ATT_FILE_SIZE)
        else:
            return 0
            # No warning is raised because older files just don&#39;t have this

    @property
    def int64_status(self):
        &#34;&#34;&#34;
        64-bit integer support for this database.

        Use ``int()`` to get the integer type used by this database.

        :return: 1 if 64-bit integers are supported, 0 otherwise
        &#34;&#34;&#34;
        # Determines whether the file uses int64s
        if ATT_64BIT_INT in self.data.ncattrs():
            return self.data.getncattr(ATT_64BIT_INT)
        else:
            return 1 if self.data.data_model == &#39;NETCDF3_64BIT_DATA&#39; else 0
            # No warning is raised because older files just don&#39;t have this

    @property
    def word_size(self):
        &#34;&#34;&#34;
        Word size of floating point variables in this database.

        Use ``float()`` to get the float type used by this database.

        :return: floating point word size
        &#34;&#34;&#34;
        try:
            result = self.data.getncattr(ATT_WORD_SIZE)
        except AttributeError:
            try:
                result = self.data.getncattr(ATT_WORD_SIZE_OLD)
            except AttributeError:
                # This should NEVER happen, but here to be safe
                raise AttributeError(&#34;Exodus database floating point word size could not be found&#34;)
        return result

    @property
    def num_qa(self):
        &#34;&#34;&#34;Number of QA records.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_QA].size
        except KeyError:
            result = 0
        return result

    @property
    def num_info(self):
        &#34;&#34;&#34;Number of info records.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_INFO].size
        except KeyError:
            result = 0
        return result

    @property
    def num_dim(self):
        &#34;&#34;&#34;Number of dimensions (coordinate axes) used in the model.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_DIM].size
        except KeyError:
            raise KeyError(&#34;Database dimensionality could not be found&#34;)

    @property
    def num_nodes(self):
        &#34;&#34;&#34;Number of nodes stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_NODES].size
        except KeyError:
            # This and following functions don&#39;t actually error in C, they return 0. I assume there&#39;s a good reason.
            result = 0
        return result

    @property
    def num_elem(self):
        &#34;&#34;&#34;Number of elements stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_ELEM].size
        except KeyError:
            result = 0
        return result

    @property
    def num_elem_blk(self):
        &#34;&#34;&#34;Number of element blocks stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_EB].size
        except KeyError:
            result = 0
        return result

    @property
    def num_node_sets(self):
        &#34;&#34;&#34;Number of node sets stored in this database.&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.num_node_sets()

        try:
            result = self.data.dimensions[DIM_NUM_NS].size
        except KeyError:
            result = 0
        return result

    @property
    def num_side_sets(self):
        &#34;&#34;&#34;Number of side sets stored in this database.&#34;&#34;&#34;
        try:
            result = self.data.dimensions[DIM_NUM_SS].size
        except KeyError:
            result = 0
        return result

    @property
    def num_time_steps(self):
        &#34;&#34;&#34;Number of time steps stored in this database.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_TIME_STEP].size
        except KeyError:
            raise KeyError(&#34;Number of database time steps could not be found&#34;)

    @property
    def num_elem_block_prop(self):
        &#34;&#34;&#34;Number of element block properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_EB_PROP)

    @property
    def num_node_set_prop(self):
        &#34;&#34;&#34;Number of node set properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_NS_PROP)

    @property
    def num_side_set_prop(self):
        &#34;&#34;&#34;Number of side set properties in this database.&#34;&#34;&#34;
        return self._get_num_object_properties(VAR_SS_PROP)

    @property
    def num_global_var(self):
        &#34;&#34;&#34;Number of global variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_GLO_VAR].size
        except KeyError:
            return 0

    @property
    def num_node_var(self):
        &#34;&#34;&#34;Number of nodal variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_NOD_VAR].size
        except KeyError:
            return 0

    @property
    def num_elem_block_var(self):
        &#34;&#34;&#34;Number of elemental variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_ELEM_VAR].size
        except KeyError:
            return 0

    @property
    def num_node_set_var(self):
        &#34;&#34;&#34;Number of node set variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_NS_VAR].size
        except KeyError:
            return 0

    @property
    def num_side_set_var(self):
        &#34;&#34;&#34;Number of side set variables.&#34;&#34;&#34;
        try:
            return self.data.dimensions[DIM_NUM_SS_VAR].size
        except KeyError:
            return 0

    # endregion

    # MODEL VARIABLE ACCESSORS

    # region Get methods

    ##############
    # Order maps #
    ##############

    def get_elem_order_map(self):
        &#34;&#34;&#34;Returns the optional element order map for this database.&#34;&#34;&#34;
        num_elem = self.num_elem
        if num_elem == 0:
            warnings.warn(&#34;Cannot retrieve an element order map if there are no elements!&#34;)
            return
        if VAR_ELEM_ORDER_MAP not in self.data.variables:
            # Return a default array from 1 to the number of elements
            warnings.warn(&#34;There is no element order map in this database!&#34;)
            return numpy.arange(1, num_elem + 1, dtype=self.int)
        return self.data.variables[VAR_ELEM_ORDER_MAP][:]

    # OK so we have two types of maps on the database: ID maps &amp; ORDER maps (also called NUMBER maps).
    # ID maps used to be called number maps and number maps used to be called order maps, which is super confusing.
    # This library supports the classic element order map (as defined in Exodus II API documentation), but does not
    # support the new &#39;number maps&#39; that the SEACAS C library has support for.

    ###########
    # ID maps #
    ###########

    # Below is an explanation of entity IDs in lieu of a proper one in any official documentation.
    # Nodes and elements have two IDs: an internal ID used by Exodus and all Exodus libraries, and a user-defined ID
    # used by analysts interacting with the database. To translate user-defined IDs to internal IDs, Exodus files store
    # an optional node ID map and element ID map. If they are not defined, user-defined IDs = internal IDs. This map
    # stores the user-defined ID for an entity at the index internal ID-1. We subtract 1 from the internal ID because
    # internal IDs are 1-based, meaning they start counting up from 1, not 0!
    # When working with element connectivity lists, we have to manually calculate the internal ID of each element since
    # connectivity lists do not store element IDs, only their constituent nodes.
    # The general formula to get the internal ID of the element at index i of element block n is as follows:
    # offset = sum(num_elem_in_block(1), num_elem_in_block(2), ..., num_elem_in_block(n - 1);
    # internal_id = offset + i + 1;
    # Example: EB1 has 7 elements, EB2 has 10 elements. The internal ID of the 4th element in EB2 is 7 + 3 + 1

    def get_node_id_map(self):
        &#34;&#34;&#34;Return the node ID map for this database.&#34;&#34;&#34;
        num_nodes = self.num_nodes
        return self.get_partial_node_id_map(1, num_nodes)

    def get_reverse_node_id_dict(self):
        &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
        nim = self.get_node_id_map()
        u2i_map = {}
        for i in range(self.num_nodes):
            u2i_map[nim[i]] = i + 1
        return u2i_map

    def get_partial_node_id_map(self, start, count):
        &#34;&#34;&#34;
        Return a subset of the node ID map for this database.

        Subset starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
        num_nodes = self.num_nodes
        if num_nodes == 0:
            raise KeyError(&#34;Cannot retrieve a node id map if there are no nodes!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;start index must be greater than 0&#34;)
        if start + count - 1 &gt; num_nodes:
            raise ValueError(&#34;start index + node count is larger than the total number of nodes&#34;)
        if VAR_NODE_ID_MAP not in self.data.variables:
            # Return a default array from start to start + count exclusive
            warnings.warn(&#34;There is no node id map in this database!&#34;)
            return numpy.arange(start, start + count, dtype=self.int)
        return self.data.variables[VAR_NODE_ID_MAP][start - 1:start + count - 1]

    def get_elem_id_map(self):
        &#34;&#34;&#34;Return the element ID map for this database.&#34;&#34;&#34;
        num_elem = self.num_elem
        return self.get_partial_elem_id_map(1, num_elem)

    def get_reverse_elem_id_dict(self):
        &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
        eim = self.get_elem_id_map()
        u2i_map = {}
        for i in range(self.num_elem):
            u2i_map[eim[i]] = i + 1
        return u2i_map

    def get_partial_elem_id_map(self, start, count):
        &#34;&#34;&#34;
        Return a subset of the element ID map for this database.

        Subset starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
        num_elem = self.num_elem
        if num_elem == 0:
            raise KeyError(&#34;Cannot retrieve a element id map if there are no elements!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;start index must be greater than 0&#34;)
        if start + count - 1 &gt; num_elem:
            raise ValueError(&#34;start index + element count is larger than the total number of elements&#34;)
        if VAR_ELEM_ID_MAP not in self.data.variables:
            # Return a default array from start to start + count exclusive
            warnings.warn(&#34;There is no element id map in this database!&#34;)
            return numpy.arange(start, start + count, dtype=self.int)
        return self.data.variables[VAR_ELEM_ID_MAP][start - 1:start + count - 1]

    def get_elem_id_map_for_block(self, obj_id):
        &#34;&#34;&#34;Reads the element ID map for the element block with specified ID.&#34;&#34;&#34;
        if self.num_elem_blk == 0:
            raise KeyError(&#34;There are no element blocks in this database!&#34;)
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        num_elem, _, _, _ = self._int_get_elem_block_params(obj_id, internal_id)
        offset = 0
        emap = self.get_elem_id_map()
        for i in range(1, internal_id):
            n, _, _, _ = self._int_get_elem_block_params(emap[i - 1], i)
            offset += n
        return self.get_partial_elem_id_map(offset + 1, num_elem)

    def get_node_set_id_map(self):
        &#34;&#34;&#34;Returns the id map for node sets (ns_prop1).&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_node_set_id_map()

        try:
            table = self.data.variables[VAR_NS_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Node set id map is missing from this database!&#34;.format(type))
        return table

    def get_side_set_id_map(self):
        &#34;&#34;&#34;Returns the id map for side sets (ss_prop1).&#34;&#34;&#34;
        try:
            table = self.data.variables[VAR_SS_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Side set id map is missing from this database!&#34;.format(type))
        return table

    def get_elem_block_id_map(self):
        &#34;&#34;&#34;Returns the id map for element blocks (eb_prop1).&#34;&#34;&#34;
        try:
            table = self.data.variables[VAR_EB_ID_MAP][:]
        except KeyError:
            raise KeyError(&#34;Element block id map is missing from this database!&#34;.format(type))
        return table

    def _lookup_id(self, obj_type: ObjectType, num):
        &#34;&#34;&#34;
        Returns the internal ID of a set or block of the given type and user-defined ID.

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object this id refers to
        :param num: user-defined ID (aka number) of the set/block
        :return: internal ID
        &#34;&#34;&#34;
        if obj_type == NODESET:
            table = self.get_node_set_id_map()
        elif obj_type == SIDESET:
            table = self.get_side_set_id_map()
        elif obj_type == ELEMBLOCK:
            table = self.get_elem_block_id_map()
        else:
            raise ValueError(&#34;{} is not a valid set/block type!&#34;.format(obj_type))
        # The C library caches information about sets including whether its sequential, so it can skip a lot of this
        internal_id = 1
        for table_id in table:
            if table_id == num:
                break
            internal_id += 1
        if internal_id &gt; len(table):
            raise KeyError(&#34;Could not find set/block of type {} with id {}&#34;.format(obj_type, num))
        return internal_id
        # The C library also does some crazy stuff with what might be the ns_status array

    def get_node_set_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the node set with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(NODESET, obj_id)

    def get_side_set_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the side set with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(SIDESET, obj_id)

    def get_elem_block_number(self, obj_id):
        &#34;&#34;&#34;
        Returns the internal ID (1-based) of the elem block with the user-defined ID.

        Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
        create an ID lookup table yourself if you plan to convert IDs often.
        &#34;&#34;&#34;
        return self._lookup_id(ELEMBLOCK, obj_id)

    ############################
    # Variables and time steps #
    ############################

    def get_all_times(self):
        &#34;&#34;&#34;Returns an array of all time values from all time steps from this database.&#34;&#34;&#34;
        try:
            result = self.data.variables[VAR_TIME_WHOLE][:]
        except KeyError:
            raise KeyError(&#34;Could not retrieve time steps from database!&#34;)
        return result

    def get_time(self, time_step):
        &#34;&#34;&#34;
        Returns the time value for specified time step.

        Time steps are 1-indexed. The first time step is at 1, and the last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if time_step &lt;= 0 or time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(time_step))
        return self.get_all_times()[time_step - 1]

    def get_nodal_var_at_time(self, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the nodal variable with given index at specified time step.

        Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_nodal_var_across_times(time_step, time_step, var_index)[0]

    def get_nodal_var_across_times(self, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the nodal variable with given index between specified time steps (inclusive).

        Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_partial_nodal_var_across_times(start_time_step, end_time_step, var_index, 1, self.num_nodes)

    def get_partial_nodal_var_across_times(self, start_time_step, end_time_step, var_index, start_index, count):
        &#34;&#34;&#34;
        Returns partial values of a nodal variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if self.num_nodes == 0:
            return [[]]
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Start time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        if var_index &lt;= 0 or var_index &gt; self.num_node_var:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        if start_index &lt;= 0:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if not self.large_model:
            # All vars stored in one variable
            try:
                # Do not subtract 1 from end (inclusive)
                result = self.data.variables[VAR_VALS_NOD_VAR_SMALL][
                         start_time_step - 1:end_time_step, var_index - 1, start_index - 1:start_index + count - 1]
            except KeyError:
                raise KeyError(&#34;Could not find the nodal variables in this database!&#34;)
        else:
            # Each var to its own variable
            try:
                result = self.data.variables[VAR_VALS_NOD_VAR_LARGE % var_index][start_time_step - 1:end_time_step, :]
            except KeyError:
                raise KeyError(&#34;Could not find nodal variable {} in this database!&#34;.format(var_index))
        return result

    def get_global_vars_at_time(self, time_step):
        &#34;&#34;&#34;
        Returns the values of the all global variables at specified time step.

        Time steps are 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_global_vars_across_times(time_step, time_step)[0]

    def get_global_vars_across_times(self, start_time_step, end_time_step):
        &#34;&#34;&#34;
        Returns the values of the all global variables between specified time steps (inclusive).

        Time steps are 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        try:
            # Do not subtract 1 from end (inclusive)
            result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, :]
        except KeyError:
            raise KeyError(&#34;Could not find global variables in this database!&#34;)
        return result

    def get_global_var_at_time(self, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the global variable with given index at specified time step.

        Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_global_var_across_times(time_step, time_step, var_index)[0]

    def get_global_var_across_times(self, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of the global variable with given index between specified time steps (inclusive).

        Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
        if var_index &lt;= 0 or var_index &gt; self.num_global_var:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        try:
            result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, var_index - 1]
        except KeyError:
            raise KeyError(&#34;Could not find global variables in this database!&#34;)
        return result

    def _int_get_partial_object_var_across_times(self, obj_type: ObjectType, internal_id, start_time_step,
                                                 end_time_step, var_index,
                                                 start_index, count):
        &#34;&#34;&#34;
        Returns partial values of an element block variable between specified time steps (inclusive).

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object this id refers to
        :param internal_id: INTERNAL (1-based) id
        :param start_time_step: start time (inclusive)
        :param end_time_step:  end time (inclusive)
        :param var_index: variable index (1-based)
        :param start_index: element start index (1-based)
        :param count: number of elements
        :return: 2d array storing the partial variable array at each time step
        &#34;&#34;&#34;

        num_steps = self.num_time_steps
        if num_steps &lt;= 0:
            raise ValueError(&#34;There are no time steps in this database!&#34;)
        if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
            raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
        if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
            raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))

        if obj_type == ELEMBLOCK:
            varname = VAR_VALS_ELEM_VAR
            numvar = self.num_elem_block_var
        elif obj_type == NODESET:
            varname = VAR_VALS_NS_VAR
            numvar = self.num_node_set_var
        elif obj_type == SIDESET:
            varname = VAR_VALS_SS_VAR
            numvar = self.num_side_set_var
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))

        if var_index &lt;= 0 or var_index &gt; numvar:
            raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
        if start_index &lt;= 0:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            result = self.data.variables[varname % (var_index, internal_id)][
                     start_time_step - 1:end_time_step, start_index - 1:start_index + count - 1]
        except KeyError:
            raise KeyError(&#34;Could not find variables of type {} in this database!&#34;.format(obj_type))
        return result

    def get_elem_block_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the element block with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_elem_block_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the element block with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        # This method cannot simply call its partial version because we cannot know the number of elements to read
        #  without looking up the id first. This extra id lookup call is slow, so we get around it with a helper method.
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                                count):
        &#34;&#34;&#34;
        Returns partial values of an element block variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def get_node_set_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the node set with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_node_set_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the node set with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        size = self._int_get_node_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                              count):
        &#34;&#34;&#34;
        Returns partial values of a node set variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def get_side_set_var_at_time(self, obj_id, time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the side set with id at time step.

        Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        return self.get_side_set_var_across_times(obj_id, time_step, time_step, var_index)[0]

    def get_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
        &#34;&#34;&#34;
        Returns the values of variable with index stored in the side set with id between time steps (inclusive).

        Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                             var_index, 1, size)

    def get_partial_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                              count):
        &#34;&#34;&#34;
        Returns partial values of a side set variable between specified time steps (inclusive).

        Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                             var_index, start_index, count)

    def _get_truth_table(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns the truth table for variables of a given object type.

        FOR INTERNAL USE ONLY!

        :param obj_type: type of object
        :return: truth table
        &#34;&#34;&#34;
        if obj_type == ELEMBLOCK:
            tabname = VAR_ELEM_TAB
            valname = VAR_VALS_ELEM_VAR
            num_entity = self.num_elem_blk
            num_var = self.num_elem_block_var
        elif obj_type == NODESET:
            tabname = VAR_NS_TAB
            valname = VAR_VALS_NS_VAR
            num_entity = self.num_node_sets
            num_var = self.num_node_set_var
        elif obj_type == SIDESET:
            tabname = VAR_SS_TAB
            valname = VAR_VALS_SS_VAR
            num_entity = self.num_side_sets
            num_var = self.num_side_set_var
        else:
            raise ValueError(&#34;Invalid object type {}!&#34;.format(obj_type))
        if tabname in self.data.variables:
            result = self.data.variables[tabname][:]
        else:
            # we have to figure it out for ourselves
            result = numpy.zeros((num_entity, num_var), dtype=self.int)
            for e in range(num_entity):
                for v in range(num_var):
                    if valname % (v + 1, e + 1) in self.data.variables:
                        result[e, v] = 1
        return result

    def get_elem_block_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for element blocks.&#34;&#34;&#34;
        return self._get_truth_table(ELEMBLOCK)

    def get_node_set_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for node sets.&#34;&#34;&#34;
        return self._get_truth_table(NODESET)

    def get_side_set_truth_table(self):
        &#34;&#34;&#34;Returns the variable truth table for side sets.&#34;&#34;&#34;
        return self._get_truth_table(SIDESET)

    def _get_var_names(self, var_type: VariableType):
        &#34;&#34;&#34;
        Returns a list of variable names for objects of a given type.

        :param var_type: the type of variable
        :return: a list of variable names
        &#34;&#34;&#34;
        if var_type == GLOBAL_VAR:
            varname = VAR_NAME_GLO_VAR
        elif var_type == NODAL_VAR:
            varname = VAR_NAME_NOD_VAR
        elif var_type == ELEMENTAL_VAR:
            varname = VAR_NAME_ELEM_VAR
        elif var_type == NODESET_VAR:
            varname = VAR_NAME_NS_VAR
        elif var_type == SIDESET_VAR:
            varname = VAR_NAME_SS_VAR
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(var_type))
        try:
            names = self.data.variables[varname][:]
        except KeyError:
            raise KeyError(&#34;No {} variable names stored in database!&#34;.format(var_type))
        result = numpy.empty([len(names)], self._MAX_NAME_LENGTH_T)
        for i in range(len(names)):
            result[i] = util.lineparse(names[i])
        return result

    def has_var_names(self, var_type: VariableType):
        &#34;&#34;&#34;
        .Test if this Exodus file has variable names for a variable type.

        :param var_type: GLOBAL_VAR, NODAL_VAR, ELEMENTAL_VAR, NODESET_VAR, or SIDESET_VAR from `constants`
        :return: True if this variable type has names defined, false otherwise
        &#34;&#34;&#34;
        if var_type == GLOBAL_VAR:
            varname = VAR_NAME_GLO_VAR
        elif var_type == NODAL_VAR:
            varname = VAR_NAME_NOD_VAR
        elif var_type == ELEMENTAL_VAR:
            varname = VAR_NAME_ELEM_VAR
        elif var_type == NODESET_VAR:
            varname = VAR_NAME_NS_VAR
        elif var_type == SIDESET_VAR:
            varname = VAR_NAME_SS_VAR
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(var_type))
        return varname in self.data.variables

    def get_global_var_names(self):
        &#34;&#34;&#34;Returns a list of all global variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(GLOBAL_VAR)

    def get_nodal_var_names(self):
        &#34;&#34;&#34;Returns a list of all nodal variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(NODAL_VAR)

    def get_elem_var_names(self):
        &#34;&#34;&#34;Returns a list of all element variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(ELEMENTAL_VAR)

    def get_node_set_var_names(self):
        &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(NODESET_VAR)

    def get_side_set_var_names(self):
        &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
        return self._get_var_names(SIDESET_VAR)

    def _get_var_name(self, var_type, index):
        &#34;&#34;&#34;Returns variable name of variable with given index of given object type.&#34;&#34;&#34;
        names = self._get_var_names(var_type)
        try:
            name = names[index - 1]
        except IndexError:
            raise IndexError(&#34;Variable index out of range. Got {}&#34;.format(index))
        return name

    def get_global_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the global variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(GLOBAL_VAR, index)

    def get_nodal_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the nodal variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(NODAL_VAR, index)

    def get_elem_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the element variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(ELEMENTAL_VAR, index)

    def get_node_set_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the node set variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(NODESET_VAR, index)

    def get_side_set_var_name(self, index):
        &#34;&#34;&#34;Returns the name of the side set variable with the given index.&#34;&#34;&#34;
        return self._get_var_name(SIDESET_VAR, index)

    ######################
    # Node and side sets #
    ######################

    def _int_get_partial_node_set(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the nodes contained in the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: node start index (1-based)
        :param count: number of nodes
        :return: array containing the selected part of the node set
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            set = self.data.variables[VAR_NODE_NS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve node set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_NODE_NS % internal_id))
        return set

    def _int_get_partial_node_set_df(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: node start index (1-based)
        :param count: number of nodes
        :return: array containing the selected part of the node set distribution factors list
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (&#39;dist_fact_ns%d&#39; % internal_id) in self.data.variables:
            set = self.data.variables[VAR_DF_NS % internal_id][start - 1:start + count - 1]
        else:
            warnings.warn(&#34;This database does not contain dist factors for node set {}&#34;.format(obj_id))
            set = []
        return set

    def _int_get_node_set_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the node set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of nodes, number of distribution factors)
        &#34;&#34;&#34;
        num_sets = self.num_node_sets
        if num_sets == 0:
            raise KeyError(&#34;No node sets are stored in this database!&#34;)
        try:
            num_entries = self.data.dimensions[DIM_NUM_NODE_NS % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of entries in node set with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_NODE_NS % internal_id))
        if (VAR_DF_NS % internal_id) in self.data.variables:
            num_df = num_entries
        else:
            num_df = 0
        return num_entries, num_df

    def get_node_set(self, identifier):
        &#34;&#34;&#34;Returns an array of the nodes contained in the node set with given ID.&#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_node_set(identifier)

        internal_id = self._lookup_id(NODESET, identifier)
        size = self._int_get_node_set_params(identifier, internal_id)[0]
        return self._int_get_partial_node_set(identifier, internal_id, 1, size)

    def get_partial_node_set(self, identifier, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the nodes contained in the node set with given ID.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
            return self.ledger.get_partial_node_set(identifier, start, count)

        internal_id = self._lookup_id(NODESET, identifier)
        return self._int_get_partial_node_set(identifier, internal_id, start, count)

    def get_node_set_df(self, obj_id):
        &#34;&#34;&#34;Returns an array containing the distribution factors in the node set with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        size = self._int_get_node_set_params(obj_id, internal_id)[1]
        return self._int_get_partial_node_set_df(obj_id, internal_id, 1, size)

    def get_partial_node_set_df(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the node set with given ID.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_partial_node_set_df(obj_id, internal_id, start, count)

    def get_node_set_params(self, obj_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the node set with given ID.

        Returned tuple is of format (number of nodes, number of distribution factors).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(NODESET, obj_id)
        return self._int_get_node_set_params(obj_id, internal_id)

    def _int_get_partial_side_set(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns tuple containing a subset of the elements and side contained in the side set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: tuple containing the selected part of the side set of format: (elements, corresponding sides)
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        try:
            elmset = self.data.variables[VAR_ELEM_SS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(
                &#34;Failed to retrieve elements of side set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_ELEM_SS % internal_id))
        try:
            sset = self.data.variables[VAR_SIDE_SS % internal_id][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(
                &#34;Failed to retrieve sides of side set with id {} (&#39;{}&#39;)&#34;.format(obj_id, VAR_SIDE_SS % internal_id))
        return elmset, sset

    def _int_get_partial_side_set_df(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the side set with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the side set distribution factors list
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (VAR_DF_SS % internal_id) in self.data.variables:
            set = self.data.variables[VAR_DF_SS % internal_id][start - 1:start + count - 1]
        else:
            warnings.warn(&#34;This database does not contain dist factors for side set {}&#34;.format(obj_id))
            set = []
        return set

    def _int_get_side_set_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the side set with given ID.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of elements, number of distribution factors)
        &#34;&#34;&#34;
        num_sets = self.num_side_sets
        if num_sets == 0:
            raise KeyError(&#34;No side sets are stored in this database!&#34;)
        try:
            num_entries = self.data.dimensions[DIM_NUM_SIDE_SS % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of entries in side set with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_SIDE_SS % internal_id))
        if DIM_NUM_DF_SS % internal_id in self.data.dimensions:
            num_df = self.data.dimensions[DIM_NUM_DF_SS % internal_id].size
        else:
            num_df = 0
        return num_entries, num_df

    def get_side_set(self, obj_id):
        &#34;&#34;&#34;
        Returns tuple containing the elements and sides contained in the side set with given ID.

        Returned tuple is of format (elements in side set, sides in side set).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[0]
        return self._int_get_partial_side_set(obj_id, internal_id, 1, size)

    def get_side_set_node_count_list(self, obj_id):
        &#34;&#34;&#34;Returns array of number of nodes per side/face.&#34;&#34;&#34;
        # Adapted from ex_get_side_set_node_count.c
        internal_id = self._lookup_id(SIDESET, obj_id)
        num_eb = self.num_elem_blk
        ndim = self.num_dim
        num_ss_elem, _ = self._int_get_side_set_params(obj_id, internal_id)
        elem_list, side_list = self.get_side_set(obj_id)
        ss_elem_idx = numpy.argsort(elem_list)
        eb_id_map = self.get_elem_block_id_map()
        eb_params = []
        elem_ctr = 0
        for i in range(num_eb):
            id = eb_id_map[i]
            eb_params.append(self._int_get_elem_block_param_object(id, ndim))
            elem_ctr += eb_params[i].num_elem_in_blk
            eb_params[i].elem_ctr = elem_ctr
        node_count_list = numpy.empty(num_ss_elem, self.int)
        j = 0  # current elem block
        for ii in range(num_ss_elem):
            i = ss_elem_idx[ii]
            elem = elem_list[i]
            side = side_list[i] - 1  # 0 based side
            while j &lt; num_eb:
                if elem &lt;= eb_params[j].elem_ctr:
                    break
                else:
                    j += 1
            if j &gt;= num_eb:
                raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
            if side &gt;= eb_params[j].num_sides:
                raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                                 (side, eb_params[j].elem_type_str, obj_id))
            node_count_list[i] = eb_params[j].num_nodes_per_side[side]
        return node_count_list

    def get_side_set_node_list(self, obj_id):
        &#34;&#34;&#34;
        Returns array of nodes for this side set and the node count list.

        :return: (node list, node count list)
        &#34;&#34;&#34;
        # Adapted from ex_get_side_set_node_list.c.
        # I really really really hope this doesn&#39;t have errors in it
        internal_id = self._lookup_id(SIDESET, obj_id)
        num_eb = self.num_elem_blk
        num_elem = self.num_elem
        ndim = self.num_dim
        num_ss_elem, num_ss_df = self._int_get_side_set_params(obj_id, internal_id)
        elem_list, side_list = self.get_side_set(obj_id)
        ss_elem_idx = numpy.argsort(elem_list)
        eb_id_map = self.get_elem_block_id_map()
        eb_params = []
        elem_ctr = 0
        for i in range(num_eb):
            id = eb_id_map[i]
            eb_params.append(self._int_get_elem_block_param_object(id, ndim))
            elem_ctr += eb_params[i].num_elem_in_blk
            eb_params[i].elem_ctr = elem_ctr
        ss_param_idx = numpy.empty(num_ss_elem, int)  # ss element to eb param index
        ss_elem_node_idx = numpy.empty(num_ss_elem, int)  # ss element to node list index
        node_count_list = numpy.empty(num_ss_elem, self.int)
        node_ctr = 0
        j = 0  # current elem block
        for ii in range(num_ss_elem):
            i = ss_elem_idx[ii]
            elem = elem_list[i]
            side = side_list[i]
            while j &lt; num_eb:
                if eb_params[j].elem_type_val != NULL:
                    if elem &lt;= eb_params[j].elem_ctr:
                        break
                    else:
                        j += 1
            if j &gt;= num_eb:
                raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
            if side &gt;= eb_params[j].num_sides:
                raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                                 (side, eb_params[j].elem_type_str, obj_id))
            ss_param_idx[i] = j
            ss_elem_node_idx[i] = eb_params[j].num_nodes_per_side[side - 1]
            node_ctr += eb_params[j].num_nodes_per_side[side - 1]

        if num_ss_df &gt; 0 and num_ss_df != num_ss_elem:
            if node_ctr != num_ss_df:
                warnings.warn(&#34;Side set %d dist fact count (%d) does not match node list length (%d)! This may indicate&#34;
                              &#34; a corrupt database.&#34; % (obj_id, num_ss_df, node_ctr))

        for i in range(num_ss_elem):
            node_count_list[i] = ss_elem_node_idx[i]

        sum = 0
        for i in range(num_ss_elem):
            cnt = ss_elem_node_idx[i]
            ss_elem_node_idx[i] = sum
            sum += cnt

        node_list = numpy.empty(node_ctr, self.int)

        elem_ctr = 0
        connect = None
        for j in range(num_ss_elem):
            elem_idx = ss_elem_idx[j]
            elem = elem_list[elem_idx]
            side = side_list[elem_idx]
            param_idx = ss_param_idx[elem_idx]

            if elem &gt; elem_ctr:
                # We&#39;re doing this the C way because copying code from SEACAS saves development time
                connect = numpy.ndarray.flatten(self.get_elem_block_connectivity(eb_params[param_idx].elem_blk_id))
                elem_ctr = eb_params[param_idx].elem_ctr

            if connect is None:
                raise ValueError(&#34;connect is None in get_side_set_node_list. This is likely the result of an abnormal&#34;
                                 &#34; Exodus file.&#34;)

            elem_num = elem - 1
            elem_num_pos = elem_num - (eb_params[param_idx].elem_ctr - eb_params[param_idx].num_elem_in_blk)

            num_nodes_per_elem = eb_params[param_idx].num_nodes_per_elem
            connect_offset = num_nodes_per_elem * elem_num_pos
            side_num = side - 1
            node_pos = ss_elem_node_idx[elem_idx]

            if eb_params[param_idx].elem_type_val == CIRCLE or eb_params[param_idx].elem_type_val == SPHERE:
                node_list[node_pos] = connect[connect_offset]
            elif eb_params[param_idx].elem_type_val == TRUSS:
                node_list[node_pos] = connect[connect_offset + side_num]
            elif eb_params[param_idx].elem_type_val == BEAM:
                for i in range(num_nodes_per_elem):
                    node_list[node_pos + i] = connect[connect_offset + i]
            elif eb_params[param_idx].elem_type_val == TRIANGLE:
                if ndim == 2:
                    if side_num + 1 &lt; 1 or side_num + 1 &gt; 3:
                        raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                    node_list[node_pos] = connect[connect_offset + tri_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + tri_table[side_num][1] - 1]
                    if num_nodes_per_elem &gt; 3:
                        node_list[node_pos + 2] = connect[connect_offset + tri_table[side_num][2] - 1]
                elif ndim == 3:
                    if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                        raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                    node_list[node_pos] = connect[connect_offset + tri3_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + tri3_table[side_num][1] - 1]
                    if side_num + 1 &lt;= 2:
                        if num_nodes_per_elem == 3:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                        elif num_nodes_per_elem == 4:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            # This looks wrong, but it&#39;s what the C library does...
                            node_list[node_pos + 2] = connect[connect_offset + 4 - 1]
                        elif num_nodes_per_elem == 6:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                            node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                            node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                        elif num_nodes_per_elem == 7:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                            node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                            node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                            node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                            node_list[node_pos + 6] = connect[connect_offset + tri3_table[side_num][6] - 1]
                        else:
                            raise ValueError(&#34;%d is an unsupported number of nodes for triangle elements!&#34; %
                                             num_nodes_per_elem)
                    else:
                        if num_nodes_per_elem &gt; 3:
                            node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == QUAD:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                    raise ValueError(&#34;Invalid quad side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + quad_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + quad_table[side_num][1] - 1]
                if num_nodes_per_elem &gt; 5:
                    node_list[node_pos + 2] = connect[connect_offset + quad_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == SHELL:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                    raise ValueError(&#34;Invalid shell side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + shell_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + shell_table[side_num][1] - 1]
                if num_nodes_per_elem &gt; 2:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
                        node_list[node_pos + 3] = connect[connect_offset + shell_table[side_num][3] - 1]
                if num_nodes_per_elem == 8:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                    else:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
                if num_nodes_per_elem == 9:
                    if side_num + 1 &lt;= 2:
                        node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + shell_table[side_num][8] - 1]
                    else:
                        node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
            elif eb_params[param_idx].elem_type_val == TETRA:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                    raise ValueError(&#34;Invalid tetra side number %d!&#34; % (side_num + 1))
                node_list[node_pos + 0] = connect[connect_offset + tetra_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + tetra_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + tetra_table[side_num][2] - 1]
                if num_nodes_per_elem == 8:
                    node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
                elif num_nodes_per_elem &gt; 8:
                    node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + tetra_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + tetra_table[side_num][5] - 1]
            elif eb_params[param_idx].elem_type_val == WEDGE:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                    raise ValueError(&#34;Invalid wedge side number %d!&#34; % (side_num + 1))
                if num_nodes_per_elem == 6 or num_nodes_per_elem == 7:
                    node_list[node_pos + 0] = connect[connect_offset + wedge6_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge6_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge6_table[side_num][2] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 3] = connect[connect_offset + wedge6_table[side_num][3] - 1]
                elif num_nodes_per_elem == 15 or num_nodes_per_elem == 16:
                    node_list[node_pos + 0] = connect[connect_offset + wedge15_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge15_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge15_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge15_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge15_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge15_table[side_num][5] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 6] = connect[connect_offset + wedge15_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + wedge15_table[side_num][7] - 1]
                elif num_nodes_per_elem == 12:
                    node_list[node_pos + 0] = connect[connect_offset + wedge12_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge12_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge12_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge12_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge12_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge12_table[side_num][5] - 1]
                elif num_nodes_per_elem == 20:
                    node_list[node_pos + 0] = connect[connect_offset + wedge20_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge20_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge20_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge20_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge20_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge20_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + wedge20_table[side_num][6] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 7] = connect[connect_offset + wedge20_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge20_table[side_num][8] - 1]
                elif num_nodes_per_elem == 21:
                    node_list[node_pos + 0] = connect[connect_offset + wedge21_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge21_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge21_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge21_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge21_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge21_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + wedge21_table[side_num][6] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 7] = connect[connect_offset + wedge21_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge21_table[side_num][8] - 1]
                elif num_nodes_per_elem == 18:
                    node_list[node_pos + 0] = connect[connect_offset + wedge18_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + wedge18_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + wedge18_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + wedge18_table[side_num][3] - 1]
                    node_list[node_pos + 4] = connect[connect_offset + wedge18_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + wedge18_table[side_num][5] - 1]
                    if side_num == 3 or side_num == 4:
                        pass
                    else:
                        node_list[node_pos + 6] = connect[connect_offset + wedge18_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + wedge18_table[side_num][7] - 1]
                        node_list[node_pos + 8] = connect[connect_offset + wedge18_table[side_num][8] - 1]
            elif eb_params[param_idx].elem_type_val == PYRAMID:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                    raise ValueError(&#34;Invalid pyramid side number %d!&#34; % (side_num + 1))
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][0] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][1] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][2] - 1]
                node_pos += 1
                if pyramid_table[side_num][3] == 0:
                    pass  # this one even confuses the C library
                else:
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][3] - 1]
                    node_pos += 1
                if num_nodes_per_elem &gt; 5:
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][4] - 1]
                    node_pos += 1
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][5] - 1]
                    node_pos += 1
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][6] - 1]
                    node_pos += 1
                    if side_num == 4:
                        node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][7] - 1]
                        node_pos += 1
                        if num_nodes_per_elem &gt;= 14:
                            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                            node_pos += 1
                    else:
                        if num_nodes_per_elem &gt;= 18:
                            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                            node_pos += 1
            elif eb_params[param_idx].elem_type_val == HEX:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                    raise ValueError(&#34;Invalid hex side number %d!&#34; % (side_num + 1))
                if num_nodes_per_elem == 16:
                    node_list[node_pos + 0] = connect[connect_offset + hex16_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + hex16_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + hex16_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][3] - 1]
                    # I have no idea whats going on with these next two statements
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][4] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][5] - 1]
                    if side_num + 1 == 5 or side_num + 1 == 6:
                        # Also no idea about these ones
                        node_list[node_pos] = connect[connect_offset + hex16_table[side_num][6] - 1]
                        node_pos += 1
                        node_list[node_pos] = connect[connect_offset + hex16_table[side_num][7] - 1]
                        node_pos += 1
                else:
                    node_list[node_pos + 0] = connect[connect_offset + hex_table[side_num][0] - 1]
                    node_list[node_pos + 1] = connect[connect_offset + hex_table[side_num][1] - 1]
                    node_list[node_pos + 2] = connect[connect_offset + hex_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + hex_table[side_num][3] - 1]
                    if num_nodes_per_elem &gt; 12:
                        node_list[node_pos + 4] = connect[connect_offset + hex_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + hex_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + hex_table[side_num][6] - 1]
                        node_list[node_pos + 7] = connect[connect_offset + hex_table[side_num][7] - 1]
                    if num_nodes_per_elem == 27:
                        node_list[node_pos + 8] = connect[connect_offset + hex_table[side_num][8] - 1]
            else:
                raise ValueError(&#34;%s is an unsupported element type.&#34; % eb_params[param_idx].elem_type_str)
        return node_list, node_count_list

    def get_partial_side_set(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns tuple containing a subset of the elements and sides contained in the side set with given ID.

        Arrays start at element number ``start`` (1-based) and contains ``count`` elements.
        Returned tuple is of format (elements in side set, sides in side set).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_side_set(obj_id, internal_id, start, count)

    def get_side_set_df(self, obj_id):
        &#34;&#34;&#34;Returns an array containing the distribution factors in the side set with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        size = self._int_get_side_set_params(obj_id, internal_id)[1]
        return self._int_get_partial_side_set_df(obj_id, internal_id, 1, size)

    def get_partial_side_set_df(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial array of the distribution factors contained in the side set with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_partial_side_set_df(obj_id, internal_id, start, count)

    def get_side_set_params(self, obj_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the side set with given ID.

        Returned tuple is of format (number of elements, number of distribution factors).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        return self._int_get_side_set_params(obj_id, internal_id)

    ##################
    # Element blocks #
    ##################

    def _int_get_partial_elem_block_connectivity(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial connectivity list for the element block with given ID.

        FOR INTERNAL USE ONLY!

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the connectivity list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        if (DIM_NUM_NOD_PER_EL % internal_id) in self.data.dimensions:
            num_node_entry = self.data.dimensions[DIM_NUM_NOD_PER_EL % internal_id].size
        else:
            num_node_entry = 0
        if num_node_entry &gt; 0:
            try:
                result = self.data.variables[VAR_CONNECT % internal_id][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve connectivity list of element block with id {} (&#39;{}&#39;)&#34;
                               .format(obj_id, VAR_CONNECT % internal_id))
        else:
            result = []
        return result

    def _int_get_elem_block_params(self, obj_id, internal_id):
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the element block with given ID.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :return: (number of elements, nodes per element, topology, number of attributes)
        &#34;&#34;&#34;
        # TODO this will be way faster with caching
        try:
            num_entries = self.data.dimensions[DIM_NUM_EL_IN_BLK % internal_id].size
        except KeyError:
            raise KeyError(&#34;Failed to retrieve number of elements in element block with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, DIM_NUM_EL_IN_BLK % internal_id))
        if (DIM_NUM_NOD_PER_EL % internal_id) in self.data.dimensions:
            num_node_entry = self.data.dimensions[DIM_NUM_NOD_PER_EL % internal_id].size
        else:
            num_node_entry = 0
        try:
            if num_node_entry &gt; 0:
                connect = self.data.variables[VAR_CONNECT % internal_id]
                topology = connect.getncattr(ATTR_ELEM_TYPE)
            else:
                topology = None
        except KeyError:
            raise KeyError(&#34;Failed to retrieve connectivity list of element block with id {} (&#39;{}&#39;)&#34;
                           .format(obj_id, VAR_CONNECT % internal_id))
        if (DIM_NUM_ATT_IN_BLK % internal_id) in self.data.dimensions:
            num_att_blk = self.data.dimensions[DIM_NUM_ATT_IN_BLK % internal_id].size
        else:
            num_att_blk = 0
        return num_entries, num_node_entry, topology, num_att_blk

    def get_elem_block_connectivity(self, obj_id):
        &#34;&#34;&#34;Returns the connectivity list for the element block with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, 1, size)

    def get_partial_elem_block_connectivity(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial connectivity list for the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, start, count)

    def get_elem_block_params(self, obj_id) -&gt; Tuple[builtins.int, builtins.int, str, builtins.int]:
        &#34;&#34;&#34;
        Returns a tuple containing the parameters for the element block with given ID.

        Returned tuple is of format (number of elements, nodes per element, topology, number of attributes).
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_elem_block_params(obj_id, internal_id)

    def _int_get_elem_block_param_object(self, obj_id, ndim) -&gt; ElemBlockParam:
        &#34;&#34;&#34;Returns parameters used to describe an elem block.&#34;&#34;&#34;
        # Adapted from ex_int_get_block_param.c
        # Used to get side set node count list
        num_el, nod_el, topo, num_att = self.get_elem_block_params(obj_id)
        topo = topo.upper()
        num_nod_side = numpy.zeros(6, builtins.int)
        if topo[:3] == CIRCLE[:3]:
            el_type = CIRCLE
            num_sides = 1
            num_nod_side[0] = 1
        elif topo[:3] == SPHERE[:3]:
            el_type = SPHERE
            num_sides = 1
            num_nod_side[0] = 1
        elif topo[:3] == QUAD[:3]:
            el_type = QUAD
            num_sides = 4
            if nod_el == 4 or nod_el == 5:
                num_nod_side[0] = 2
                num_nod_side[1] = 2
                num_nod_side[2] = 2
                num_nod_side[3] = 2
            elif nod_el == 9 or nod_el == 8:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
            elif nod_el == 12 or nod_el == 16:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TRIANGLE[:3]:
            el_type = TRIANGLE
            if ndim == 2:
                num_sides = 3
                if nod_el == 3 or nod_el == 4:
                    num_nod_side[0] = 2
                    num_nod_side[1] = 2
                    num_nod_side[2] = 2
                elif nod_el == 6 or nod_el == 7:
                    num_nod_side[0] = 3
                    num_nod_side[1] = 3
                    num_nod_side[2] = 3
                elif nod_el == 9 or nod_el == 13:
                    num_nod_side[0] = 4
                    num_nod_side[1] = 4
                    num_nod_side[2] = 4
                else:
                    raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
            elif ndim == 3:
                num_sides = 5
                if nod_el == 3 or nod_el == 4:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 2
                    num_nod_side[3] = 2
                    num_nod_side[4] = 2
                elif nod_el == 6 or nod_el == 7:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 3
                    num_nod_side[3] = 3
                    num_nod_side[4] = 3
                elif nod_el == 9 or nod_el == 13:
                    num_nod_side[0] = nod_el
                    num_nod_side[1] = nod_el
                    num_nod_side[2] = 4
                    num_nod_side[3] = 4
                    num_nod_side[4] = 4
                else:
                    raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == SHELL[:3]:
            el_type = SHELL
            if nod_el == 2:
                num_sides = 2
                num_nod_side[0] = 2
                num_nod_side[1] = 2
            elif nod_el == 4:
                num_sides = 6
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 2
                num_nod_side[3] = 2
                num_nod_side[4] = 2
                num_nod_side[5] = 2
            elif nod_el == 8 or nod_el == 9:
                num_sides = 6
                num_nod_side[0] = nod_el
                num_nod_side[1] = nod_el
                num_nod_side[2] = 3
                num_nod_side[3] = 3
                num_nod_side[4] = 3
                num_nod_side[5] = 3
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == HEX[:3]:
            el_type = HEX
            num_sides = 6
            if nod_el == 8 or nod_el == 9:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
                num_nod_side[4] = 4
                num_nod_side[5] = 4
            elif nod_el == 12:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 4
                num_nod_side[5] = 4
            elif nod_el == 16:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 8
                num_nod_side[5] = 8
            elif nod_el == 20:
                num_nod_side[0] = 8
                num_nod_side[1] = 8
                num_nod_side[2] = 8
                num_nod_side[3] = 8
                num_nod_side[4] = 8
                num_nod_side[5] = 8
            elif nod_el == 27:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 9
                num_nod_side[4] = 9
                num_nod_side[5] = 9
            elif nod_el == 32:
                num_nod_side[0] = 12
                num_nod_side[1] = 12
                num_nod_side[2] = 12
                num_nod_side[3] = 12
                num_nod_side[4] = 12
                num_nod_side[5] = 12
            elif nod_el == 64:
                num_nod_side[0] = 16
                num_nod_side[1] = 16
                num_nod_side[2] = 16
                num_nod_side[3] = 16
                num_nod_side[4] = 16
                num_nod_side[5] = 16
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TETRA[:3]:
            el_type = TETRA
            num_sides = 4
            if nod_el == 4 or nod_el == 5:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
            elif nod_el == 8:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 4
            elif nod_el == 10 or nod_el == 11:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
            elif nod_el == 14 or nod_el == 15:
                num_nod_side[0] = 7
                num_nod_side[1] = 7
                num_nod_side[2] = 7
                num_nod_side[3] = 7
            elif nod_el == 16:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 9
            elif nod_el == 40:
                num_nod_side[0] = 13
                num_nod_side[1] = 13
                num_nod_side[2] = 13
                num_nod_side[3] = 13
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == WEDGE[:3]:
            el_type = WEDGE
            num_sides = 5
            if nod_el == 6:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
                num_nod_side[2] = 4
                num_nod_side[3] = 3
                num_nod_side[4] = 3
            elif nod_el == 12:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 15 or nod_el == 16:
                num_nod_side[0] = 8
                num_nod_side[1] = 8
                num_nod_side[2] = 8
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 18:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 6
                num_nod_side[4] = 6
            elif nod_el == 20 or nod_el == 21:
                num_nod_side[0] = 9
                num_nod_side[1] = 9
                num_nod_side[2] = 9
                num_nod_side[3] = 7
                num_nod_side[4] = 7
            elif nod_el == 24:
                num_nod_side[0] = 12
                num_nod_side[1] = 12
                num_nod_side[2] = 12
                num_nod_side[3] = 9
                num_nod_side[4] = 9
            elif nod_el == 52:
                num_nod_side[0] = 16
                num_nod_side[1] = 16
                num_nod_side[2] = 16
                num_nod_side[3] = 13
                num_nod_side[4] = 13
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == PYRAMID[:3]:
            el_type = PYRAMID
            num_sides = 5
            if nod_el == 5:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
                num_nod_side[2] = 3
                num_nod_side[3] = 3
                num_nod_side[4] = 4
            elif nod_el == 13:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 8
            elif nod_el == 14:
                num_nod_side[0] = 6
                num_nod_side[1] = 6
                num_nod_side[2] = 6
                num_nod_side[3] = 6
                num_nod_side[4] = 9
            elif nod_el == 18 or nod_el == 19:
                num_nod_side[0] = 7
                num_nod_side[1] = 7
                num_nod_side[2] = 7
                num_nod_side[3] = 7
                num_nod_side[4] = 9
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == BEAM[:3]:
            el_type = BEAM
            num_sides = 2
            if nod_el == 2:
                num_nod_side[0] = 2
                num_nod_side[1] = 2
            elif nod_el == 3:
                num_nod_side[0] = 3
                num_nod_side[1] = 3
            elif nod_el == 4:
                num_nod_side[0] = 4
                num_nod_side[1] = 4
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        elif topo[:3] == TRUSS[:3] or topo[:3] == BAR[:3] or topo[:3] == EDGE[:3]:
            el_type = TRUSS
            num_sides = 2
            if nod_el == 2 or nod_el == 3:
                num_nod_side[0] = 1
                num_nod_side[1] = 1
            else:
                raise ValueError(&#34;Element of type %s with %d nodes is invalid!&#34; % (topo, nod_el))
        # Special case for null elements
        elif topo[:3] == NULL[:3]:
            el_type = NULL
            num_sides = 0
            num_nod_side[0] = 0
            num_el = 0
        else:
            el_type = UNKNOWN
            num_sides = 0
            num_nod_side[0] = 0
        return ElemBlockParam(topo, obj_id, num_el, nod_el, num_sides, num_nod_side, num_att, 0, el_type)

    #########
    # Names #
    #########

    def _get_set_block_names(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns a list of names for objects of a given type.
        :param obj_type: type of object
        :return: a list of names
        &#34;&#34;&#34;
        names = []
        if obj_type == NODESET:
            try:
                names = self.data.variables[VAR_NS_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain node set names.&#34;)
        elif obj_type == SIDESET:
            try:
                names = self.data.variables[VAR_SS_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain side set names.&#34;)
        elif obj_type == ELEMBLOCK:
            try:
                names = self.data.variables[VAR_EB_NAMES]
            except KeyError:
                warnings.warn(&#34;This database does not contain element block names.&#34;)
        else:
            raise ValueError(&#34;{} is not a valid set/block type!&#34;.format(obj_type))
        result = numpy.empty([len(names)], self._MAX_NAME_LENGTH_T)
        for i in range(len(names)):
            result[i] = util.lineparse(names[i])
        return result

    def get_elem_block_names(self):
        &#34;&#34;&#34;Returns an array containing the names of element blocks in this database.&#34;&#34;&#34;
        return self._get_set_block_names(ELEMBLOCK)

    def get_elem_block_name(self, obj_id):
        &#34;&#34;&#34;Returns the name of the given element block.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        names = self._get_set_block_names(ELEMBLOCK)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    def get_node_set_names(self):
        &#34;&#34;&#34;Returns an array containing the names of node sets in this database.&#34;&#34;&#34;
        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            return self.ledger.get_node_set_names()
        return self._get_set_block_names(NODESET)

    def get_node_set_name(self, identifier):
        &#34;&#34;&#34;Returns the name of the given node set.&#34;&#34;&#34;
        if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
            return self.ledger.get_node_set_name(identifier)

        internal_id = self._lookup_id(NODESET, identifier)
        names = self._get_set_block_names(NODESET)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    def get_side_set_names(self):
        &#34;&#34;&#34;Returns an array containing the names of side sets in this database.&#34;&#34;&#34;
        return self._get_set_block_names(SIDESET)

    def get_side_set_name(self, obj_id):
        &#34;&#34;&#34;Returns the name of the given side set.&#34;&#34;&#34;
        internal_id = self._lookup_id(SIDESET, obj_id)
        names = self._get_set_block_names(SIDESET)
        if len(names) &gt; 0:
            return names[internal_id - 1]
        else:
            return None

    ######################
    # Element Attributes #
    ######################

    def _int_get_num_elem_attrib(self, internal_id):
        &#34;&#34;&#34;
        Returns the number of attributes in the element block with given internal ID.

        FOR INTERNAL USE ONLY!
        &#34;&#34;&#34;
        # Some databases don&#39;t have attributes
        if (DIM_NUM_ATT_IN_BLK % internal_id) in self.data.dimensions:
            num = self.data.dimensions[DIM_NUM_ATT_IN_BLK % internal_id].size
        else:
            # No need to warn. If there are no attributes, the number is 0...
            num = 0
        return num

    def _int_get_partial_elem_attrib(self, obj_id, internal_id, start, count):
        &#34;&#34;&#34;
        Returns a partial list of all attributes for the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the attribute list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        varname = VAR_ELEM_ATTRIB % internal_id
        if varname in self.data.variables:
            result = self.data.variables[varname][start - 1:start + count - 1, :]
        else:
            result = []
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        return result

    def _int_get_partial_one_elem_attrib(self, obj_id, internal_id, attrib_index, start, count):
        &#34;&#34;&#34;
        Returns a partial list of one attribute for the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.

        FOR INTERNAL USE ONLY

        :param obj_id: EXTERNAL (user-defined) id
        :param internal_id: INTERNAL (1-based) id
        :param attrib_index: attribute index (1-based)
        :param start: element start index (1-based)
        :param count: number of elements
        :return: array containing the selected part of the attribute list
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        num_attrib = self._int_get_num_elem_attrib(internal_id)
        if num_attrib &gt; 0:  # faster to check this than if the variable exists like in the function above this one
            if attrib_index &lt; 1 or attrib_index &gt; num_attrib:
                raise ValueError(&#34;Attribute index out of range. Got {}&#34;.format(attrib_index))
            result = self.data.variables[VAR_ELEM_ATTRIB % internal_id][start - 1:start + count - 1, attrib_index - 1]
        else:
            result = []
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        return result

    def get_partial_one_elem_attrib(self, obj_id, attrib_index, start, count):
        &#34;&#34;&#34;
        Returns a partial list of one attribute for the specified elements in the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, start, count)

    def get_one_elem_attrib(self, obj_id, attrib_index):
        &#34;&#34;&#34;
        Returns a list of one attribute for each element in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, 1, size)

    def get_elem_attrib(self, obj_id):
        &#34;&#34;&#34;
        Returns a list of all attributes for each element in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        size = self._int_get_elem_block_params(obj_id, internal_id)[0]
        return self._int_get_partial_elem_attrib(obj_id, internal_id, 1, size)

    def get_partial_elem_attrib(self, obj_id, start, count):
        &#34;&#34;&#34;
        Returns a partial list of all attributes for the specified elements in the element block with given ID.

        Array starts at element number ``start`` (1-based) and contains ``count`` elements.
        Returns an empty array if the element block doesn&#39;t have attributes.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_partial_elem_attrib(obj_id, internal_id, start, count)

    def get_elem_attrib_names(self, obj_id):
        &#34;&#34;&#34;
        Returns a list of the names of attributes in the element block with given ID.

        Returns an empty array if the element block doesn&#39;t have attributes or attribute names.
        &#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        num_attrib = self._int_get_num_elem_attrib(internal_id)
        result = []
        if num_attrib == 0:
            warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
        else:
            varname = VAR_ELEM_ATTRIB_NAME % internal_id
            # Older datasets don&#39;t have attribute names
            if varname in self.data.variables:
                names = self.data.variables[varname][:]
                result = util.arrparse(names, len(names), self._MAX_NAME_LENGTH_T)
            else:
                warnings.warn(&#34;Attributes of element block {} have no names.&#34;.format(obj_id))
        return result

    def get_num_elem_attrib(self, obj_id):
        &#34;&#34;&#34;Returns the number of attributes in the element block with given ID.&#34;&#34;&#34;
        internal_id = self._lookup_id(ELEMBLOCK, obj_id)
        return self._int_get_num_elem_attrib(internal_id)

    #####################
    # Object properties #
    #####################

    # This method contains a general algorithm for counting the number of properties an object has.
    # This is used by the num_*_prop properties which are in turn used by _get_object_property_names
    def _get_num_object_properties(self, varname):
        &#34;&#34;&#34;
        Returns the number of properties an object has.

        :param varname: the netCDF variable name of the property. (&#34;xx_prop_%d&#34;) where xx is ns, ss, or eb
        :return: number of properties
        &#34;&#34;&#34;
        # loop over the prop variables and count how many there are
        n = 0
        while True:
            if varname % (n + 1) in self.data.variables:
                n += 1
            else:
                break
        return n

    def _get_object_property(self, obj_type: ObjectType, obj_id, name):
        &#34;&#34;&#34;
        Returns the value of a specific object&#39;s property.

        :param obj_type: type of object this id refers to
        :param obj_id: EXTERNAL (user-defined) id
        :param name: name of the property
        :return: value of the property for the specified object
        &#34;&#34;&#34;
        internal_id = self._lookup_id(obj_type, obj_id)
        prop = self._get_object_property_array(obj_type, name)
        # We don&#39;t want to index into prop if it&#39;s empty
        if len(prop) &gt; 0:
            return prop[internal_id - 1]
        else:
            return None

    def get_node_set_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the node set with the given ID.&#34;&#34;&#34;
        return self._get_object_property(NODESET, obj_id, name)

    def get_side_set_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the side set with the given ID.&#34;&#34;&#34;
        return self._get_object_property(SIDESET, obj_id, name)

    def get_elem_block_property(self, obj_id, name):
        &#34;&#34;&#34;Returns the value of the specified property for the element block with the given ID.&#34;&#34;&#34;
        return self._get_object_property(ELEMBLOCK, obj_id, name)

    def _get_object_property_array(self, obj_type: ObjectType, name):
        &#34;&#34;&#34;
        Returns a list containing all the values of a particular property for objects of a given type.

        :param obj_type: type of object this id refers to
        :param name: name of the property
        :return: array containing values of the property for objects of the given type
        &#34;&#34;&#34;
        if obj_type == NODESET:
            varname = VAR_NS_PROP
        elif obj_type == SIDESET:
            varname = VAR_SS_PROP
        elif obj_type == ELEMBLOCK:
            varname = VAR_EB_PROP
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))
        prop = []
        # Search for the property for the right name
        # We don&#39;t use a for loop over the number of props because that would cost a second loop over the props
        n = 1
        while True:
            if varname % n in self.data.variables:
                propname = self.data.variables[varname % n].getncattr(ATTR_NAME)
                if propname == name:
                    # we&#39;ve found our property
                    prop = self.data.variables[varname % n][:]
                    break
                else:
                    # check next property
                    n += 1
                    continue
            else:
                # &#34;xx_prop_n&#34; doesn&#39;t exist. name doesn&#39;t exist in file
                warnings.warn(&#34;Property {} does not exist!&#34;.format(name))
                break
        return prop

    def get_node_set_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all node sets.&#34;&#34;&#34;
        return self._get_object_property_array(NODESET, name)

    def get_side_set_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all side sets.&#34;&#34;&#34;
        return self._get_object_property_array(SIDESET, name)

    def get_elem_block_property_array(self, name):
        &#34;&#34;&#34;Returns a list containing the values of the specified property for all element blocks.&#34;&#34;&#34;
        return self._get_object_property_array(ELEMBLOCK, name)

    def _get_object_property_names(self, obj_type: ObjectType):
        &#34;&#34;&#34;
        Returns a list containing the names of properties defined for objects of a given type.

        :param obj_type: type of object
        :return: array of property names
        &#34;&#34;&#34;
        if obj_type == NODESET:
            varname = VAR_NS_PROP
            num_props = self.num_node_set_prop
        elif obj_type == SIDESET:
            varname = VAR_SS_PROP
            num_props = self.num_side_set_prop
        elif obj_type == ELEMBLOCK:
            varname = VAR_EB_PROP
            num_props = self.num_elem_block_prop
        else:
            raise ValueError(&#34;Invalid variable type {}!&#34;.format(obj_type))
        # num_props = self._get_num_object_properties(varname)
        result = numpy.empty([num_props], self._MAX_NAME_LENGTH_T)
        for n in range(num_props):
            result[n] = self.data.variables[varname % (n + 1)].getncattr(ATTR_NAME)
        return result

    def get_node_set_property_names(self):
        &#34;&#34;&#34;Returns a list of node set property names.&#34;&#34;&#34;
        return self._get_object_property_names(NODESET)

    def get_side_set_property_names(self):
        &#34;&#34;&#34;Returns a list of side set property names.&#34;&#34;&#34;
        return self._get_object_property_names(SIDESET)

    def get_elem_block_property_names(self):
        &#34;&#34;&#34;Returns a list of element block property names.&#34;&#34;&#34;
        return self._get_object_property_names(ELEMBLOCK)

    ###############
    # Coordinates #
    ###############

    def get_coords(self):
        &#34;&#34;&#34;Returns a multidimensional array containing the coordinates of all nodes.&#34;&#34;&#34;
        # Technically this incurs an extra call to num_nodes, but the reduced complexity is worth it
        return self.get_partial_coords(1, self.num_nodes)

    def get_partial_coords(self, start, count):
        &#34;&#34;&#34;
        Returns a multidimensional array containing the coordinates of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][:, start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coordx = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
            if dim_cnt &gt; 1:
                try:
                    coordy = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
                except KeyError:
                    raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
                if dim_cnt &gt; 2:
                    try:
                        coordz = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
                    except KeyError:
                        raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
                    coord = numpy.array([coordx, coordy, coordz])
                else:
                    coord = numpy.array([coordx, coordy])
            else:
                coord = coordx
        return coord

    def get_coord_x(self):
        &#34;&#34;&#34;Returns an array containing the x coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_x(1, self.num_nodes)

    def get_partial_coord_x(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the x coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        num_nodes = self.num_nodes
        if num_nodes == 0:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][0][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
        return coord

    def get_coord_y(self):
        &#34;&#34;&#34;Returns an array containing the y coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_y(1, self.num_nodes)

    def get_partial_coord_y(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the y coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0 or dim_cnt &lt; 2:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][1][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
        return coord

    def get_coord_z(self):
        &#34;&#34;&#34;Returns an array containing the z coordinate of all nodes.&#34;&#34;&#34;
        return self.get_partial_coord_z(1, self.num_nodes)

    def get_partial_coord_z(self, start, count):
        &#34;&#34;&#34;
        Returns an array containing the z coordinate of the specified set of nodes.

        Array starts at node number ``start`` (1-based) and contains ``count`` elements.
        &#34;&#34;&#34;
        if start &lt; 1:
            raise ValueError(&#34;Start index must be greater than 0&#34;)
        if count &lt; 0:
            raise ValueError(&#34;Count must be a positive integer&#34;)
        dim_cnt = self.num_dim
        num_nodes = self.num_nodes
        if num_nodes == 0 or dim_cnt &lt; 3:
            return []
        large = self.large_model
        if not large:
            try:
                coord = self.data.variables[VAR_COORD][2][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
        else:
            try:
                coord = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
        return coord

    def get_coord_names(self):
        &#34;&#34;&#34;Returns an array containing the names of the coordinate axes in this database.&#34;&#34;&#34;
        dim_cnt = self.num_dim
        try:
            names = self.data.variables[VAR_COORD_NAMES]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve coordinate name array!&#34;)
        result = util.arrparse(names, dim_cnt, self._MAX_NAME_LENGTH_T)
        return result

    ################
    # File records #
    ################

    def get_info(self):
        &#34;&#34;&#34;Returns an array containing the info records stored in this database.&#34;&#34;&#34;
        num = self.num_info
        result = numpy.empty([num], Exodus._MAX_LINE_LENGTH_T)
        if num &gt; 0:
            try:
                infos = self.data.variables[VAR_INFO]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve info records from database!&#34;)
            for i in range(num):
                result[i] = util.lineparse(infos[i])
        return result

    def get_qa(self):
        &#34;&#34;&#34;Returns an n x 4 array containing the QA records stored in this database.&#34;&#34;&#34;
        num = self.num_qa
        result = numpy.empty([num, 4], Exodus._MAX_STR_LENGTH_T)
        if num &gt; 0:
            try:
                qas = self.data.variables[VAR_QA]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve qa records from database!&#34;)
            for i in range(num):
                for j in range(4):
                    result[i, j] = util.lineparse(qas[i, j])
        return result

    # endregion

    @property
    def time_steps(self):
        &#34;&#34;&#34;Returns list of the time steps, 0-indexed&#34;&#34;&#34;
        return [*range(self.num_time_steps)]

    def step_at_time(self, time):
        &#34;&#34;&#34;Given a float time value, return the corresponding time step&#34;&#34;&#34;
        for index, value in enumerate(self.get_all_times()):
            if value == time:
                return index
        return None

    def get_dimension(self, name):
        if name in self.data.dimensions:
            return self.data.dimensions[name].size
        else:
            raise RuntimeError(&#34;dimensions &#39;{}&#39; cannot be found!&#34;.format(name))

    def get_parameter(self, name):
        if name in self.data.ncattrs():
            return self.data.getncattr(name)
        else:
            raise RuntimeError(&#34;parameter &#39;{}&#39; cannot be found!&#34;.format(name))

    def close(self):
        self.data.close()

    def print_dimensions(self):
        for dim in self.data.dimensions.values():
            print(dim)

    def print_dimension_names(self):
        for dim in self.data.dimensions:
            print(dim)

    def print_variables(self):
        for v in self.data.variables.values():
            print(v, &#34;\n&#34;)

    def print_variable_names(self):
        for v in self.data.variables:
            print(v)

    def set_nodeset(self, node_set_id, node_ids):
        ndx = node_set_id - 1
        if &#34;ns_prop1&#34; in self.data.variables:
            ndx = numpy.where(self.data.variables[&#34;ns_prop1&#34;][:] == node_set_id)[0][0]
            ndx += 1

        key = &#34;node_ns&#34; + str(ndx)
        nodeset = self.data[key]

        if &#34;node_num_map&#34; in self.data.variables:
            indices = numpy.zeros(len(node_ids))
            i = 0
            for id in node_ids:
                ndx = numpy.where(self.data[&#34;node_num_map&#34;][:] == id)[0][0]
                indices[i] = ndx
                i += 1
            nodeset[:] = indices
            return
        nodeset[:] = node_ids

    def get_nodes_in_elblock(self, id):
        if &#34;node_num_map&#34; in self.data.variables:
            raise Exception(&#34;Using node num map&#34;)
        nodeids = self.data[&#34;connect&#34; + str(id)]
        # flatten it into 1d
        nodeids = nodeids[:].flatten()
        return nodeids

    def diff(self, other):
        # # Nodesets
        selfNS = self.num_node_sets
        otherNS = other.num_node_sets
        print(&#34;Self # Nodesets:\t{}&#34;.format(selfNS))
        print(&#34;Other # Nodesets:\t{}&#34;.format(otherNS))

        # # Sidesets
        selfSS = self.num_side_sets
        otherSS = other.num_side_sets
        print(&#34;\nSelf # Sidesets:\t{}&#34;.format(selfSS))
        print(&#34;Other # Sidesets:\t{}&#34;.format(otherSS))

        # # Nodes
        selfN = self.num_nodes
        otherN = other.num_nodes
        print(&#34;\nSelf # Nodes:\t\t{}&#34;.format(selfN))
        print(&#34;Other # Nodes:\t\t{}&#34;.format(otherN))

        # # Elements
        selfE = self.num_elem
        otherE = other.num_elem
        print(&#34;\nSelf # Elements:\t{}&#34;.format(selfE))
        print(&#34;Other # Elements:\t{}\n&#34;.format(otherE))

        # Length of output variables (nodal/elemental)

    def diff_nodeset(self, id, other, id2=None):
        &#34;&#34;&#34;
        Prints the overlap and difference between two nodesets
        :param id: the nodeset ID of the self Exodus object
        :param other: the other Exodus object to compare to
        :param id2: optional parameter specifying the nodeset ID of other Exodus object. Default to the first id.
        &#34;&#34;&#34;

        if other is None:
            raise ValueError(&#34;Other Exodus file is None&#34;)

        if id2 is None:
            id2 = id
        try:
            ns1 = self.get_node_set(id)
        except KeyError:
            raise KeyError(&#34;Self Exodus file does not contain nodeset with ID {}&#34;.format(id))

        try:
            ns2 = other.get_node_set(id2)
        except KeyError:
            raise KeyError(&#34;Other Exodus file does not contain nodeset with ID {}&#34;.format(id2))

        equivalent = numpy.array_equal(numpy.array(sorted(ns1.tolist())), numpy.array(sorted(ns2.tolist())))
        if equivalent:
            print(&#34;Self NS {} contains the same Node IDs as Other NS ID {}&#34;.format(id, id2))
        else:
            print(&#34;Self NS ID {} does NOT contain the same nodes as Other NS ID {}&#34;.format(id, id2))
            intersection = set(ns1) &amp; set(ns2)
            print(&#34;\tBoth nodesets share the following nodes:\n\t{}&#34;.format(sorted(list(intersection))))
            ns1_diff = sorted(list(set(ns1) - intersection))
            print(&#34;\tSelf NS ID {} also contains nodes:\n\t{}&#34;.format(id, ns1_diff))
            ns2_diff = sorted(list(set(ns2) - intersection))
            print(&#34;\tOther NS ID {} also contains nodes:\n\t{}\n&#34;.format(id2, ns2_diff))

    ################################################################
    #                                                              #
    #                        Write                                 #
    #                                                              #
    ################################################################

    def add_nodeset(self, node_ids, nodeset_id, nodeset_name=&#34;&#34;):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_nodeset(node_ids, nodeset_id, nodeset_name)

    def remove_nodeset(self, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_nodeset(identifier)

    def merge_nodeset(self, new_id, ns1, ns2, delete=True):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.merge_nodesets(new_id, ns1, ns2, delete)

    def add_node_to_nodeset(self, node_id, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_node_to_nodeset(node_id, identifier)

    def add_nodes_to_nodeset(self, node_ids, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_nodes_to_nodeset(node_ids, identifier)

    def remove_node_from_nodeset(self, node_id, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_node_from_nodeset(node_id, identifier)

    def remove_nodes_from_nodeset(self, node_ids, identifier):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_nodes_from_nodeset(node_ids, identifier)

    def add_sideset(self, elem_ids, side_ids, ss_id, ss_name, dist_fact=None, variables=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_sideset(elem_ids, side_ids, ss_id, ss_name, dist_fact, variables)

    def remove_sideset(self, ss_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_sideset(ss_id)


    def add_sides_to_sideset(self, elem_ids, side_ids, ss_id, dist_facts=None, variables=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.add_sides_to_sideset(elem_ids, side_ids, ss_id, dist_facts, variables)

    def remove_sides_from_sideset(self, elem_ids, side_ids, ss_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        self.ledger.remove_sides_from_sideset(elem_ids, side_ids, ss_id)

    def split_sideset(self, old_ss, function, ss_id1, ss_id2, delete, ss_name1=&#34;&#34;, ss_name2=&#34;&#34;):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to split sideset&#34;)
        self.ledger.split_sideset(old_ss, function, ss_id1, ss_id2, delete, ss_name1, ss_name2)
    

    def add_element(self, block_id, nodelist):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        return self.ledger.add_element(block_id, nodelist)


    def remove_element(self, elem_id):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
        return self.ledger.remove_element(elem_id)

    def skin_element_block(self, block_id, skin_id, skin_name):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
        self.ledger.skin_element_block(block_id, skin_id, skin_name)

    def skin(self, skin_id, skin_name):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
        self.ledger.skin(skin_id, skin_name)
        
    def write(self, path=None):
        if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
            raise PermissionError(&#34;Need to be in write or append mode to write&#34;)
        elif self.mode == &#39;a&#39; and path is None:
            raise AttributeError(&#34;Must specify a new path when in append mode&#34;)
        elif self.mode == &#39;w&#39; and path is not None:
            raise AttributeError(&#34;Do not specify a new path in write mode. Initialization path will be used&#34;)
        self.ledger.write(path)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exodus.Exodus.api_version"><code class="name">var <span class="ident">api_version</span></code></dt>
<dd>
<div class="desc"><p>The Exodus API version this database was built with.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api_version(self):
    &#34;&#34;&#34;The Exodus API version this database was built with.&#34;&#34;&#34;
    try:
        result = self.data.getncattr(ATT_API_VER)
    except AttributeError:
        # Try the old way of spelling it
        try:
            result = self.data.getncattr(ATT_API_VER_OLD)
        except AttributeError:
            raise AttributeError(&#34;Exodus API version could not be found&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.float"><code class="name">var <span class="ident">float</span></code></dt>
<dd>
<div class="desc"><p>The floating-point type stored in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def float(self):
    &#34;&#34;&#34;The floating-point type stored in the database.&#34;&#34;&#34;
    # Returns floating point type of floating point numbers stored in the database
    # You may use whatever crazy types you want while coding, but convert them before storing them in the DB
    return self._float</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.int"><code class="name">var <span class="ident">int</span></code></dt>
<dd>
<div class="desc"><p>The integer type stored in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def int(self):
    &#34;&#34;&#34;The integer type stored in the database.&#34;&#34;&#34;
    # Returns integer type of integers stored in the database
    return self._int</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.int64_status"><code class="name">var <span class="ident">int64_status</span></code></dt>
<dd>
<div class="desc"><p>64-bit integer support for this database.</p>
<p>Use <code>int()</code> to get the integer type used by this database.</p>
<p>:return: 1 if 64-bit integers are supported, 0 otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def int64_status(self):
    &#34;&#34;&#34;
    64-bit integer support for this database.

    Use ``int()`` to get the integer type used by this database.

    :return: 1 if 64-bit integers are supported, 0 otherwise
    &#34;&#34;&#34;
    # Determines whether the file uses int64s
    if ATT_64BIT_INT in self.data.ncattrs():
        return self.data.getncattr(ATT_64BIT_INT)
    else:
        return 1 if self.data.data_model == &#39;NETCDF3_64BIT_DATA&#39; else 0
        # No warning is raised because older files just don&#39;t have this</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.large_model"><code class="name">var <span class="ident">large_model</span></code></dt>
<dd>
<div class="desc"><p>Describes how coordinates are stored in this database.</p>
<p>If true: nodal coordinates and variables are stored in separate x, y, z variables.
If false: nodal coordinates and variables are stored in a single variable.</p>
<p>:return: 1 if stored separately (large), 0 if stored in a blob</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def large_model(self):
    &#34;&#34;&#34;
    Describes how coordinates are stored in this database.

    If true: nodal coordinates and variables are stored in separate x, y, z variables.
    If false: nodal coordinates and variables are stored in a single variable.

    :return: 1 if stored separately (large), 0 if stored in a blob
    &#34;&#34;&#34;
    # According to a comment in ex_utils.c @ line 1614
    # &#34;Basically, the difference is whether the coordinates and nodal variables are stored in a blob (xyz components
    # together) or as a variable per component per nodal_variable.&#34;
    # This is important for coordinate getter functions
    if ATT_FILE_SIZE in self.data.ncattrs():
        return self.data.getncattr(ATT_FILE_SIZE)
    else:
        return 0
        # No warning is raised because older files just don&#39;t have this</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.max_allowed_name_length"><code class="name">var <span class="ident">max_allowed_name_length</span></code></dt>
<dd>
<div class="desc"><p>The maximum allowed length for variable/dimension/attribute names in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_allowed_name_length(self):
    &#34;&#34;&#34;The maximum allowed length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
    max_name_len = Exodus._MAX_NAME_LENGTH
    if DIM_NAME_LENGTH in self.data.dimensions:
        # Subtract 1 because in C an extra null character is added for C reasons
        max_name_len = self.data.dimensions[DIM_NAME_LENGTH].size - 1
    return max_name_len</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.max_line_length"><code class="name">var <span class="ident">max_line_length</span></code></dt>
<dd>
<div class="desc"><p>Maximum info record line length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_line_length(self):
    &#34;&#34;&#34;Maximum info record line length.&#34;&#34;&#34;
    # See ex_put_info.c @ line 121. This record is created and used when adding info records
    max_line_len = Exodus._MAX_LINE_LENGTH
    if DIM_LINE_LENGTH in self.data.dimensions:
        # Subtract 1 because in C an extra character is added for C reasons
        max_line_len = self.data.dimensions[DIM_LINE_LENGTH].size - 1
    return max_line_len</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.max_string_length"><code class="name">var <span class="ident">max_string_length</span></code></dt>
<dd>
<div class="desc"><p>Maximum QA record string length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_string_length(self):
    &#34;&#34;&#34;Maximum QA record string length.&#34;&#34;&#34;
    # See ex_put_qa.c @ line 119. This record is created and used when adding QA records
    max_str_len = Exodus._MAX_STR_LENGTH
    if DIM_STRING_LENGTH in self.data.dimensions:
        # Subtract 1 because in C an extra character is added for C reasons
        max_str_len = self.data.dimensions[DIM_STRING_LENGTH].size - 1
    return max_str_len</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.max_used_name_length"><code class="name">var <span class="ident">max_used_name_length</span></code></dt>
<dd>
<div class="desc"><p>The maximum used length for variable/dimension/attribute names in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_used_name_length(self):
    &#34;&#34;&#34;The maximum used length for variable/dimension/attribute names in this database.&#34;&#34;&#34;
    # 32 is the default size consistent with other databases
    max_used_name_len = 32
    if ATT_MAX_NAME_LENGTH in self.data.ncattrs():
        # The length does not include the added null character from C
        max_used_name_len = self.data.getncattr(ATT_MAX_NAME_LENGTH)
    return max_used_name_len</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_dim"><code class="name">var <span class="ident">num_dim</span></code></dt>
<dd>
<div class="desc"><p>Number of dimensions (coordinate axes) used in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_dim(self):
    &#34;&#34;&#34;Number of dimensions (coordinate axes) used in the model.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_DIM].size
    except KeyError:
        raise KeyError(&#34;Database dimensionality could not be found&#34;)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_elem"><code class="name">var <span class="ident">num_elem</span></code></dt>
<dd>
<div class="desc"><p>Number of elements stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_elem(self):
    &#34;&#34;&#34;Number of elements stored in this database.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_ELEM].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_elem_blk"><code class="name">var <span class="ident">num_elem_blk</span></code></dt>
<dd>
<div class="desc"><p>Number of element blocks stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_elem_blk(self):
    &#34;&#34;&#34;Number of element blocks stored in this database.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_EB].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_elem_block_prop"><code class="name">var <span class="ident">num_elem_block_prop</span></code></dt>
<dd>
<div class="desc"><p>Number of element block properties in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_elem_block_prop(self):
    &#34;&#34;&#34;Number of element block properties in this database.&#34;&#34;&#34;
    return self._get_num_object_properties(VAR_EB_PROP)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_elem_block_var"><code class="name">var <span class="ident">num_elem_block_var</span></code></dt>
<dd>
<div class="desc"><p>Number of elemental variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_elem_block_var(self):
    &#34;&#34;&#34;Number of elemental variables.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_ELEM_VAR].size
    except KeyError:
        return 0</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_global_var"><code class="name">var <span class="ident">num_global_var</span></code></dt>
<dd>
<div class="desc"><p>Number of global variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_global_var(self):
    &#34;&#34;&#34;Number of global variables.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_GLO_VAR].size
    except KeyError:
        return 0</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_info"><code class="name">var <span class="ident">num_info</span></code></dt>
<dd>
<div class="desc"><p>Number of info records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_info(self):
    &#34;&#34;&#34;Number of info records.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_INFO].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_node_set_prop"><code class="name">var <span class="ident">num_node_set_prop</span></code></dt>
<dd>
<div class="desc"><p>Number of node set properties in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_node_set_prop(self):
    &#34;&#34;&#34;Number of node set properties in this database.&#34;&#34;&#34;
    return self._get_num_object_properties(VAR_NS_PROP)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_node_set_var"><code class="name">var <span class="ident">num_node_set_var</span></code></dt>
<dd>
<div class="desc"><p>Number of node set variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_node_set_var(self):
    &#34;&#34;&#34;Number of node set variables.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_NS_VAR].size
    except KeyError:
        return 0</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_node_sets"><code class="name">var <span class="ident">num_node_sets</span></code></dt>
<dd>
<div class="desc"><p>Number of node sets stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_node_sets(self):
    &#34;&#34;&#34;Number of node sets stored in this database.&#34;&#34;&#34;
    if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
        return self.ledger.num_node_sets()

    try:
        result = self.data.dimensions[DIM_NUM_NS].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_node_var"><code class="name">var <span class="ident">num_node_var</span></code></dt>
<dd>
<div class="desc"><p>Number of nodal variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_node_var(self):
    &#34;&#34;&#34;Number of nodal variables.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_NOD_VAR].size
    except KeyError:
        return 0</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_nodes"><code class="name">var <span class="ident">num_nodes</span></code></dt>
<dd>
<div class="desc"><p>Number of nodes stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_nodes(self):
    &#34;&#34;&#34;Number of nodes stored in this database.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_NODES].size
    except KeyError:
        # This and following functions don&#39;t actually error in C, they return 0. I assume there&#39;s a good reason.
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_qa"><code class="name">var <span class="ident">num_qa</span></code></dt>
<dd>
<div class="desc"><p>Number of QA records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_qa(self):
    &#34;&#34;&#34;Number of QA records.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_QA].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_side_set_prop"><code class="name">var <span class="ident">num_side_set_prop</span></code></dt>
<dd>
<div class="desc"><p>Number of side set properties in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_side_set_prop(self):
    &#34;&#34;&#34;Number of side set properties in this database.&#34;&#34;&#34;
    return self._get_num_object_properties(VAR_SS_PROP)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_side_set_var"><code class="name">var <span class="ident">num_side_set_var</span></code></dt>
<dd>
<div class="desc"><p>Number of side set variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_side_set_var(self):
    &#34;&#34;&#34;Number of side set variables.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_SS_VAR].size
    except KeyError:
        return 0</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_side_sets"><code class="name">var <span class="ident">num_side_sets</span></code></dt>
<dd>
<div class="desc"><p>Number of side sets stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_side_sets(self):
    &#34;&#34;&#34;Number of side sets stored in this database.&#34;&#34;&#34;
    try:
        result = self.data.dimensions[DIM_NUM_SS].size
    except KeyError:
        result = 0
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.num_time_steps"><code class="name">var <span class="ident">num_time_steps</span></code></dt>
<dd>
<div class="desc"><p>Number of time steps stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_time_steps(self):
    &#34;&#34;&#34;Number of time steps stored in this database.&#34;&#34;&#34;
    try:
        return self.data.dimensions[DIM_NUM_TIME_STEP].size
    except KeyError:
        raise KeyError(&#34;Number of database time steps could not be found&#34;)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.time_steps"><code class="name">var <span class="ident">time_steps</span></code></dt>
<dd>
<div class="desc"><p>Returns list of the time steps, 0-indexed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_steps(self):
    &#34;&#34;&#34;Returns list of the time steps, 0-indexed&#34;&#34;&#34;
    return [*range(self.num_time_steps)]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"><p>The database title.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def title(self):
    &#34;&#34;&#34;The database title.&#34;&#34;&#34;
    try:
        return self.data.getncattr(ATT_TITLE)
    except AttributeError:
        AttributeError(&#34;Database title could not be found&#34;)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"><p>The Exodus version this database uses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self):
    &#34;&#34;&#34;The Exodus version this database uses.&#34;&#34;&#34;
    try:
        return self.data.getncattr(ATT_VERSION)
    except AttributeError:
        raise AttributeError(&#34;Exodus database version could not be found&#34;)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.word_size"><code class="name">var <span class="ident">word_size</span></code></dt>
<dd>
<div class="desc"><p>Word size of floating point variables in this database.</p>
<p>Use <code>float()</code> to get the float type used by this database.</p>
<p>:return: floating point word size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def word_size(self):
    &#34;&#34;&#34;
    Word size of floating point variables in this database.

    Use ``float()`` to get the float type used by this database.

    :return: floating point word size
    &#34;&#34;&#34;
    try:
        result = self.data.getncattr(ATT_WORD_SIZE)
    except AttributeError:
        try:
            result = self.data.getncattr(ATT_WORD_SIZE_OLD)
        except AttributeError:
            # This should NEVER happen, but here to be safe
            raise AttributeError(&#34;Exodus database floating point word size could not be found&#34;)
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exodus.Exodus.add_element"><code class="name flex">
<span>def <span class="ident">add_element</span></span>(<span>self, block_id, nodelist)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_element(self, block_id, nodelist):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    return self.ledger.add_element(block_id, nodelist)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.add_node_to_nodeset"><code class="name flex">
<span>def <span class="ident">add_node_to_nodeset</span></span>(<span>self, node_id, identifier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node_to_nodeset(self, node_id, identifier):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.add_node_to_nodeset(node_id, identifier)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.add_nodes_to_nodeset"><code class="name flex">
<span>def <span class="ident">add_nodes_to_nodeset</span></span>(<span>self, node_ids, identifier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_nodes_to_nodeset(self, node_ids, identifier):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.add_nodes_to_nodeset(node_ids, identifier)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.add_nodeset"><code class="name flex">
<span>def <span class="ident">add_nodeset</span></span>(<span>self, node_ids, nodeset_id, nodeset_name='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_nodeset(self, node_ids, nodeset_id, nodeset_name=&#34;&#34;):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.add_nodeset(node_ids, nodeset_id, nodeset_name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.add_sides_to_sideset"><code class="name flex">
<span>def <span class="ident">add_sides_to_sideset</span></span>(<span>self, elem_ids, side_ids, ss_id, dist_facts=None, variables=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sides_to_sideset(self, elem_ids, side_ids, ss_id, dist_facts=None, variables=None):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.add_sides_to_sideset(elem_ids, side_ids, ss_id, dist_facts, variables)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.add_sideset"><code class="name flex">
<span>def <span class="ident">add_sideset</span></span>(<span>self, elem_ids, side_ids, ss_id, ss_name, dist_fact=None, variables=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sideset(self, elem_ids, side_ids, ss_id, ss_name, dist_fact=None, variables=None):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.add_sideset(elem_ids, side_ids, ss_id, ss_name, dist_fact, variables)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.data.close()</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self, other):
    # # Nodesets
    selfNS = self.num_node_sets
    otherNS = other.num_node_sets
    print(&#34;Self # Nodesets:\t{}&#34;.format(selfNS))
    print(&#34;Other # Nodesets:\t{}&#34;.format(otherNS))

    # # Sidesets
    selfSS = self.num_side_sets
    otherSS = other.num_side_sets
    print(&#34;\nSelf # Sidesets:\t{}&#34;.format(selfSS))
    print(&#34;Other # Sidesets:\t{}&#34;.format(otherSS))

    # # Nodes
    selfN = self.num_nodes
    otherN = other.num_nodes
    print(&#34;\nSelf # Nodes:\t\t{}&#34;.format(selfN))
    print(&#34;Other # Nodes:\t\t{}&#34;.format(otherN))

    # # Elements
    selfE = self.num_elem
    otherE = other.num_elem
    print(&#34;\nSelf # Elements:\t{}&#34;.format(selfE))
    print(&#34;Other # Elements:\t{}\n&#34;.format(otherE))

    # Length of output variables (nodal/elemental)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.diff_nodeset"><code class="name flex">
<span>def <span class="ident">diff_nodeset</span></span>(<span>self, id, other, id2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the overlap and difference between two nodesets
:param id: the nodeset ID of the self Exodus object
:param other: the other Exodus object to compare to
:param id2: optional parameter specifying the nodeset ID of other Exodus object. Default to the first id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff_nodeset(self, id, other, id2=None):
    &#34;&#34;&#34;
    Prints the overlap and difference between two nodesets
    :param id: the nodeset ID of the self Exodus object
    :param other: the other Exodus object to compare to
    :param id2: optional parameter specifying the nodeset ID of other Exodus object. Default to the first id.
    &#34;&#34;&#34;

    if other is None:
        raise ValueError(&#34;Other Exodus file is None&#34;)

    if id2 is None:
        id2 = id
    try:
        ns1 = self.get_node_set(id)
    except KeyError:
        raise KeyError(&#34;Self Exodus file does not contain nodeset with ID {}&#34;.format(id))

    try:
        ns2 = other.get_node_set(id2)
    except KeyError:
        raise KeyError(&#34;Other Exodus file does not contain nodeset with ID {}&#34;.format(id2))

    equivalent = numpy.array_equal(numpy.array(sorted(ns1.tolist())), numpy.array(sorted(ns2.tolist())))
    if equivalent:
        print(&#34;Self NS {} contains the same Node IDs as Other NS ID {}&#34;.format(id, id2))
    else:
        print(&#34;Self NS ID {} does NOT contain the same nodes as Other NS ID {}&#34;.format(id, id2))
        intersection = set(ns1) &amp; set(ns2)
        print(&#34;\tBoth nodesets share the following nodes:\n\t{}&#34;.format(sorted(list(intersection))))
        ns1_diff = sorted(list(set(ns1) - intersection))
        print(&#34;\tSelf NS ID {} also contains nodes:\n\t{}&#34;.format(id, ns1_diff))
        ns2_diff = sorted(list(set(ns2) - intersection))
        print(&#34;\tOther NS ID {} also contains nodes:\n\t{}\n&#34;.format(id2, ns2_diff))</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_all_times"><code class="name flex">
<span>def <span class="ident">get_all_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array of all time values from all time steps from this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_times(self):
    &#34;&#34;&#34;Returns an array of all time values from all time steps from this database.&#34;&#34;&#34;
    try:
        result = self.data.variables[VAR_TIME_WHOLE][:]
    except KeyError:
        raise KeyError(&#34;Could not retrieve time steps from database!&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_coord_names"><code class="name flex">
<span>def <span class="ident">get_coord_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the names of the coordinate axes in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_names(self):
    &#34;&#34;&#34;Returns an array containing the names of the coordinate axes in this database.&#34;&#34;&#34;
    dim_cnt = self.num_dim
    try:
        names = self.data.variables[VAR_COORD_NAMES]
    except KeyError:
        raise KeyError(&#34;Failed to retrieve coordinate name array!&#34;)
    result = util.arrparse(names, dim_cnt, self._MAX_NAME_LENGTH_T)
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_coord_x"><code class="name flex">
<span>def <span class="ident">get_coord_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the x coordinate of all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_x(self):
    &#34;&#34;&#34;Returns an array containing the x coordinate of all nodes.&#34;&#34;&#34;
    return self.get_partial_coord_x(1, self.num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_coord_y"><code class="name flex">
<span>def <span class="ident">get_coord_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the y coordinate of all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_y(self):
    &#34;&#34;&#34;Returns an array containing the y coordinate of all nodes.&#34;&#34;&#34;
    return self.get_partial_coord_y(1, self.num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_coord_z"><code class="name flex">
<span>def <span class="ident">get_coord_z</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the z coordinate of all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_z(self):
    &#34;&#34;&#34;Returns an array containing the z coordinate of all nodes.&#34;&#34;&#34;
    return self.get_partial_coord_z(1, self.num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_coords"><code class="name flex">
<span>def <span class="ident">get_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a multidimensional array containing the coordinates of all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coords(self):
    &#34;&#34;&#34;Returns a multidimensional array containing the coordinates of all nodes.&#34;&#34;&#34;
    # Technically this incurs an extra call to num_nodes, but the reduced complexity is worth it
    return self.get_partial_coords(1, self.num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_dimension"><code class="name flex">
<span>def <span class="ident">get_dimension</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dimension(self, name):
    if name in self.data.dimensions:
        return self.data.dimensions[name].size
    else:
        raise RuntimeError(&#34;dimensions &#39;{}&#39; cannot be found!&#34;.format(name))</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_attrib"><code class="name flex">
<span>def <span class="ident">get_elem_attrib</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all attributes for each element in the element block with given ID.</p>
<p>Returns an empty array if the element block doesn't have attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_attrib(self, obj_id):
    &#34;&#34;&#34;
    Returns a list of all attributes for each element in the element block with given ID.

    Returns an empty array if the element block doesn&#39;t have attributes.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    size = self._int_get_elem_block_params(obj_id, internal_id)[0]
    return self._int_get_partial_elem_attrib(obj_id, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_attrib_names"><code class="name flex">
<span>def <span class="ident">get_elem_attrib_names</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the names of attributes in the element block with given ID.</p>
<p>Returns an empty array if the element block doesn't have attributes or attribute names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_attrib_names(self, obj_id):
    &#34;&#34;&#34;
    Returns a list of the names of attributes in the element block with given ID.

    Returns an empty array if the element block doesn&#39;t have attributes or attribute names.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    num_attrib = self._int_get_num_elem_attrib(internal_id)
    result = []
    if num_attrib == 0:
        warnings.warn(&#34;Element block {} has no attributes.&#34;.format(obj_id))
    else:
        varname = VAR_ELEM_ATTRIB_NAME % internal_id
        # Older datasets don&#39;t have attribute names
        if varname in self.data.variables:
            names = self.data.variables[varname][:]
            result = util.arrparse(names, len(names), self._MAX_NAME_LENGTH_T)
        else:
            warnings.warn(&#34;Attributes of element block {} have no names.&#34;.format(obj_id))
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_connectivity"><code class="name flex">
<span>def <span class="ident">get_elem_block_connectivity</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the connectivity list for the element block with given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_connectivity(self, obj_id):
    &#34;&#34;&#34;Returns the connectivity list for the element block with given ID.&#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    size = self._int_get_elem_block_params(obj_id, internal_id)[0]
    return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_id_map"><code class="name flex">
<span>def <span class="ident">get_elem_block_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the id map for element blocks (eb_prop1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_id_map(self):
    &#34;&#34;&#34;Returns the id map for element blocks (eb_prop1).&#34;&#34;&#34;
    try:
        table = self.data.variables[VAR_EB_ID_MAP][:]
    except KeyError:
        raise KeyError(&#34;Element block id map is missing from this database!&#34;.format(type))
    return table</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_name"><code class="name flex">
<span>def <span class="ident">get_elem_block_name</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the given element block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_name(self, obj_id):
    &#34;&#34;&#34;Returns the name of the given element block.&#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    names = self._get_set_block_names(ELEMBLOCK)
    if len(names) &gt; 0:
        return names[internal_id - 1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_names"><code class="name flex">
<span>def <span class="ident">get_elem_block_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the names of element blocks in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_names(self):
    &#34;&#34;&#34;Returns an array containing the names of element blocks in this database.&#34;&#34;&#34;
    return self._get_set_block_names(ELEMBLOCK)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_number"><code class="name flex">
<span>def <span class="ident">get_elem_block_number</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the internal ID (1-based) of the elem block with the user-defined ID.</p>
<p>Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
create an ID lookup table yourself if you plan to convert IDs often.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_number(self, obj_id):
    &#34;&#34;&#34;
    Returns the internal ID (1-based) of the elem block with the user-defined ID.

    Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
    create an ID lookup table yourself if you plan to convert IDs often.
    &#34;&#34;&#34;
    return self._lookup_id(ELEMBLOCK, obj_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_params"><code class="name flex">
<span>def <span class="ident">get_elem_block_params</span></span>(<span>self, obj_id) ‑> Tuple[int, int, str, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple containing the parameters for the element block with given ID.</p>
<p>Returned tuple is of format (number of elements, nodes per element, topology, number of attributes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_params(self, obj_id) -&gt; Tuple[builtins.int, builtins.int, str, builtins.int]:
    &#34;&#34;&#34;
    Returns a tuple containing the parameters for the element block with given ID.

    Returned tuple is of format (number of elements, nodes per element, topology, number of attributes).
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_elem_block_params(obj_id, internal_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_property"><code class="name flex">
<span>def <span class="ident">get_elem_block_property</span></span>(<span>self, obj_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the specified property for the element block with the given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_property(self, obj_id, name):
    &#34;&#34;&#34;Returns the value of the specified property for the element block with the given ID.&#34;&#34;&#34;
    return self._get_object_property(ELEMBLOCK, obj_id, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_property_array"><code class="name flex">
<span>def <span class="ident">get_elem_block_property_array</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list containing the values of the specified property for all element blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_property_array(self, name):
    &#34;&#34;&#34;Returns a list containing the values of the specified property for all element blocks.&#34;&#34;&#34;
    return self._get_object_property_array(ELEMBLOCK, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_property_names"><code class="name flex">
<span>def <span class="ident">get_elem_block_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of element block property names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_property_names(self):
    &#34;&#34;&#34;Returns a list of element block property names.&#34;&#34;&#34;
    return self._get_object_property_names(ELEMBLOCK)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_truth_table"><code class="name flex">
<span>def <span class="ident">get_elem_block_truth_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable truth table for element blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_truth_table(self):
    &#34;&#34;&#34;Returns the variable truth table for element blocks.&#34;&#34;&#34;
    return self._get_truth_table(ELEMBLOCK)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_var_across_times"><code class="name flex">
<span>def <span class="ident">get_elem_block_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the element block with id between time steps (inclusive).</p>
<p>Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the element block with id between time steps (inclusive).

    Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    # This method cannot simply call its partial version because we cannot know the number of elements to read
    #  without looking up the id first. This extra id lookup call is slow, so we get around it with a helper method.
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    size = self._int_get_elem_block_params(obj_id, internal_id)[0]
    return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                         var_index, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_block_var_at_time"><code class="name flex">
<span>def <span class="ident">get_elem_block_var_at_time</span></span>(<span>self, obj_id, time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the element block with id at time step.</p>
<p>Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_block_var_at_time(self, obj_id, time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the element block with id at time step.

    Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_elem_block_var_across_times(obj_id, time_step, time_step, var_index)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_id_map"><code class="name flex">
<span>def <span class="ident">get_elem_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the element ID map for this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_id_map(self):
    &#34;&#34;&#34;Return the element ID map for this database.&#34;&#34;&#34;
    num_elem = self.num_elem
    return self.get_partial_elem_id_map(1, num_elem)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_id_map_for_block"><code class="name flex">
<span>def <span class="ident">get_elem_id_map_for_block</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the element ID map for the element block with specified ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_id_map_for_block(self, obj_id):
    &#34;&#34;&#34;Reads the element ID map for the element block with specified ID.&#34;&#34;&#34;
    if self.num_elem_blk == 0:
        raise KeyError(&#34;There are no element blocks in this database!&#34;)
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    num_elem, _, _, _ = self._int_get_elem_block_params(obj_id, internal_id)
    offset = 0
    emap = self.get_elem_id_map()
    for i in range(1, internal_id):
        n, _, _, _ = self._int_get_elem_block_params(emap[i - 1], i)
        offset += n
    return self.get_partial_elem_id_map(offset + 1, num_elem)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_order_map"><code class="name flex">
<span>def <span class="ident">get_elem_order_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the optional element order map for this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_order_map(self):
    &#34;&#34;&#34;Returns the optional element order map for this database.&#34;&#34;&#34;
    num_elem = self.num_elem
    if num_elem == 0:
        warnings.warn(&#34;Cannot retrieve an element order map if there are no elements!&#34;)
        return
    if VAR_ELEM_ORDER_MAP not in self.data.variables:
        # Return a default array from 1 to the number of elements
        warnings.warn(&#34;There is no element order map in this database!&#34;)
        return numpy.arange(1, num_elem + 1, dtype=self.int)
    return self.data.variables[VAR_ELEM_ORDER_MAP][:]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_var_name"><code class="name flex">
<span>def <span class="ident">get_elem_var_name</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the element variable with the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_var_name(self, index):
    &#34;&#34;&#34;Returns the name of the element variable with the given index.&#34;&#34;&#34;
    return self._get_var_name(ELEMENTAL_VAR, index)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_elem_var_names"><code class="name flex">
<span>def <span class="ident">get_elem_var_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all element variable names. Index of the variable is the index of the name + 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elem_var_names(self):
    &#34;&#34;&#34;Returns a list of all element variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
    return self._get_var_names(ELEMENTAL_VAR)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_var_across_times"><code class="name flex">
<span>def <span class="ident">get_global_var_across_times</span></span>(<span>self, start_time_step, end_time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the global variable with given index between specified time steps (inclusive).</p>
<p>Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_var_across_times(self, start_time_step, end_time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of the global variable with given index between specified time steps (inclusive).

    Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    num_steps = self.num_time_steps
    if num_steps &lt;= 0:
        raise ValueError(&#34;There are no time steps in this database!&#34;)
    if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
        raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
    if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
        raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
    if var_index &lt;= 0 or var_index &gt; self.num_global_var:
        raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
    try:
        result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, var_index - 1]
    except KeyError:
        raise KeyError(&#34;Could not find global variables in this database!&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_var_at_time"><code class="name flex">
<span>def <span class="ident">get_global_var_at_time</span></span>(<span>self, time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the global variable with given index at specified time step.</p>
<p>Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_var_at_time(self, time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of the global variable with given index at specified time step.

    Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_global_var_across_times(time_step, time_step, var_index)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_var_name"><code class="name flex">
<span>def <span class="ident">get_global_var_name</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the global variable with the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_var_name(self, index):
    &#34;&#34;&#34;Returns the name of the global variable with the given index.&#34;&#34;&#34;
    return self._get_var_name(GLOBAL_VAR, index)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_var_names"><code class="name flex">
<span>def <span class="ident">get_global_var_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all global variable names. Index of the variable is the index of the name + 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_var_names(self):
    &#34;&#34;&#34;Returns a list of all global variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
    return self._get_var_names(GLOBAL_VAR)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_vars_across_times"><code class="name flex">
<span>def <span class="ident">get_global_vars_across_times</span></span>(<span>self, start_time_step, end_time_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the all global variables between specified time steps (inclusive).</p>
<p>Time steps are 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_vars_across_times(self, start_time_step, end_time_step):
    &#34;&#34;&#34;
    Returns the values of the all global variables between specified time steps (inclusive).

    Time steps are 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    num_steps = self.num_time_steps
    if num_steps &lt;= 0:
        raise ValueError(&#34;There are no time steps in this database!&#34;)
    if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
        raise ValueError(&#34;Time step out of range. Got {}&#34;.format(start_time_step))
    if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
        raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
    try:
        # Do not subtract 1 from end (inclusive)
        result = self.data.variables[VAR_VALS_GLO_VAR][start_time_step - 1:end_time_step, :]
    except KeyError:
        raise KeyError(&#34;Could not find global variables in this database!&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_global_vars_at_time"><code class="name flex">
<span>def <span class="ident">get_global_vars_at_time</span></span>(<span>self, time_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the all global variables at specified time step.</p>
<p>Time steps are 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_vars_at_time(self, time_step):
    &#34;&#34;&#34;
    Returns the values of the all global variables at specified time step.

    Time steps are 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_global_vars_across_times(time_step, time_step)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_info"><code class="name flex">
<span>def <span class="ident">get_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the info records stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_info(self):
    &#34;&#34;&#34;Returns an array containing the info records stored in this database.&#34;&#34;&#34;
    num = self.num_info
    result = numpy.empty([num], Exodus._MAX_LINE_LENGTH_T)
    if num &gt; 0:
        try:
            infos = self.data.variables[VAR_INFO]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve info records from database!&#34;)
        for i in range(num):
            result[i] = util.lineparse(infos[i])
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_nodal_var_across_times"><code class="name flex">
<span>def <span class="ident">get_nodal_var_across_times</span></span>(<span>self, start_time_step, end_time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the nodal variable with given index between specified time steps (inclusive).</p>
<p>Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodal_var_across_times(self, start_time_step, end_time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of the nodal variable with given index between specified time steps (inclusive).

    Time steps and variable index are both 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_partial_nodal_var_across_times(start_time_step, end_time_step, var_index, 1, self.num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_nodal_var_at_time"><code class="name flex">
<span>def <span class="ident">get_nodal_var_at_time</span></span>(<span>self, time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of the nodal variable with given index at specified time step.</p>
<p>Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodal_var_at_time(self, time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of the nodal variable with given index at specified time step.

    Time step and variable index are both 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_nodal_var_across_times(time_step, time_step, var_index)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_nodal_var_name"><code class="name flex">
<span>def <span class="ident">get_nodal_var_name</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the nodal variable with the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodal_var_name(self, index):
    &#34;&#34;&#34;Returns the name of the nodal variable with the given index.&#34;&#34;&#34;
    return self._get_var_name(NODAL_VAR, index)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_nodal_var_names"><code class="name flex">
<span>def <span class="ident">get_nodal_var_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all nodal variable names. Index of the variable is the index of the name + 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodal_var_names(self):
    &#34;&#34;&#34;Returns a list of all nodal variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
    return self._get_var_names(NODAL_VAR)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_id_map"><code class="name flex">
<span>def <span class="ident">get_node_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the node ID map for this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_id_map(self):
    &#34;&#34;&#34;Return the node ID map for this database.&#34;&#34;&#34;
    num_nodes = self.num_nodes
    return self.get_partial_node_id_map(1, num_nodes)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set"><code class="name flex">
<span>def <span class="ident">get_node_set</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array of the nodes contained in the node set with given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set(self, identifier):
    &#34;&#34;&#34;Returns an array of the nodes contained in the node set with given ID.&#34;&#34;&#34;
    if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
        return self.ledger.get_node_set(identifier)

    internal_id = self._lookup_id(NODESET, identifier)
    size = self._int_get_node_set_params(identifier, internal_id)[0]
    return self._int_get_partial_node_set(identifier, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_df"><code class="name flex">
<span>def <span class="ident">get_node_set_df</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the distribution factors in the node set with given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_df(self, obj_id):
    &#34;&#34;&#34;Returns an array containing the distribution factors in the node set with given ID.&#34;&#34;&#34;
    internal_id = self._lookup_id(NODESET, obj_id)
    size = self._int_get_node_set_params(obj_id, internal_id)[1]
    return self._int_get_partial_node_set_df(obj_id, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_id_map"><code class="name flex">
<span>def <span class="ident">get_node_set_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the id map for node sets (ns_prop1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_id_map(self):
    &#34;&#34;&#34;Returns the id map for node sets (ns_prop1).&#34;&#34;&#34;
    if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
        return self.ledger.get_node_set_id_map()

    try:
        table = self.data.variables[VAR_NS_ID_MAP][:]
    except KeyError:
        raise KeyError(&#34;Node set id map is missing from this database!&#34;.format(type))
    return table</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_name"><code class="name flex">
<span>def <span class="ident">get_node_set_name</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the given node set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_name(self, identifier):
    &#34;&#34;&#34;Returns the name of the given node set.&#34;&#34;&#34;
    if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
        return self.ledger.get_node_set_name(identifier)

    internal_id = self._lookup_id(NODESET, identifier)
    names = self._get_set_block_names(NODESET)
    if len(names) &gt; 0:
        return names[internal_id - 1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_names"><code class="name flex">
<span>def <span class="ident">get_node_set_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the names of node sets in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_names(self):
    &#34;&#34;&#34;Returns an array containing the names of node sets in this database.&#34;&#34;&#34;
    if self.mode == &#39;a&#39; or self.mode == &#39;w&#39;:
        return self.ledger.get_node_set_names()
    return self._get_set_block_names(NODESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_number"><code class="name flex">
<span>def <span class="ident">get_node_set_number</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the internal ID (1-based) of the node set with the user-defined ID.</p>
<p>Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
create an ID lookup table yourself if you plan to convert IDs often.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_number(self, obj_id):
    &#34;&#34;&#34;
    Returns the internal ID (1-based) of the node set with the user-defined ID.

    Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
    create an ID lookup table yourself if you plan to convert IDs often.
    &#34;&#34;&#34;
    return self._lookup_id(NODESET, obj_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_params"><code class="name flex">
<span>def <span class="ident">get_node_set_params</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple containing the parameters for the node set with given ID.</p>
<p>Returned tuple is of format (number of nodes, number of distribution factors).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_params(self, obj_id):
    &#34;&#34;&#34;
    Returns a tuple containing the parameters for the node set with given ID.

    Returned tuple is of format (number of nodes, number of distribution factors).
    &#34;&#34;&#34;
    internal_id = self._lookup_id(NODESET, obj_id)
    return self._int_get_node_set_params(obj_id, internal_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_property"><code class="name flex">
<span>def <span class="ident">get_node_set_property</span></span>(<span>self, obj_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the specified property for the node set with the given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_property(self, obj_id, name):
    &#34;&#34;&#34;Returns the value of the specified property for the node set with the given ID.&#34;&#34;&#34;
    return self._get_object_property(NODESET, obj_id, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_property_array"><code class="name flex">
<span>def <span class="ident">get_node_set_property_array</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list containing the values of the specified property for all node sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_property_array(self, name):
    &#34;&#34;&#34;Returns a list containing the values of the specified property for all node sets.&#34;&#34;&#34;
    return self._get_object_property_array(NODESET, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_property_names"><code class="name flex">
<span>def <span class="ident">get_node_set_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of node set property names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_property_names(self):
    &#34;&#34;&#34;Returns a list of node set property names.&#34;&#34;&#34;
    return self._get_object_property_names(NODESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_truth_table"><code class="name flex">
<span>def <span class="ident">get_node_set_truth_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable truth table for node sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_truth_table(self):
    &#34;&#34;&#34;Returns the variable truth table for node sets.&#34;&#34;&#34;
    return self._get_truth_table(NODESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_var_across_times"><code class="name flex">
<span>def <span class="ident">get_node_set_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the node set with id between time steps (inclusive).</p>
<p>Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the node set with id between time steps (inclusive).

    Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(NODESET, obj_id)
    size = self._int_get_node_set_params(obj_id, internal_id)[0]
    return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                         var_index, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_var_at_time"><code class="name flex">
<span>def <span class="ident">get_node_set_var_at_time</span></span>(<span>self, obj_id, time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the node set with id at time step.</p>
<p>Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_var_at_time(self, obj_id, time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the node set with id at time step.

    Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_node_set_var_across_times(obj_id, time_step, time_step, var_index)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_var_name"><code class="name flex">
<span>def <span class="ident">get_node_set_var_name</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the node set variable with the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_var_name(self, index):
    &#34;&#34;&#34;Returns the name of the node set variable with the given index.&#34;&#34;&#34;
    return self._get_var_name(NODESET_VAR, index)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_node_set_var_names"><code class="name flex">
<span>def <span class="ident">get_node_set_var_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all node set variable names. Index of the variable is the index of the name + 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_set_var_names(self):
    &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
    return self._get_var_names(NODESET_VAR)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_nodes_in_elblock"><code class="name flex">
<span>def <span class="ident">get_nodes_in_elblock</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes_in_elblock(self, id):
    if &#34;node_num_map&#34; in self.data.variables:
        raise Exception(&#34;Using node num map&#34;)
    nodeids = self.data[&#34;connect&#34; + str(id)]
    # flatten it into 1d
    nodeids = nodeids[:].flatten()
    return nodeids</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_num_elem_attrib"><code class="name flex">
<span>def <span class="ident">get_num_elem_attrib</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of attributes in the element block with given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_elem_attrib(self, obj_id):
    &#34;&#34;&#34;Returns the number of attributes in the element block with given ID.&#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_num_elem_attrib(internal_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_one_elem_attrib"><code class="name flex">
<span>def <span class="ident">get_one_elem_attrib</span></span>(<span>self, obj_id, attrib_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of one attribute for each element in the element block with given ID.</p>
<p>Returns an empty array if the element block doesn't have attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_one_elem_attrib(self, obj_id, attrib_index):
    &#34;&#34;&#34;
    Returns a list of one attribute for each element in the element block with given ID.

    Returns an empty array if the element block doesn&#39;t have attributes.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    size = self._int_get_elem_block_params(obj_id, internal_id)[0]
    return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter(self, name):
    if name in self.data.ncattrs():
        return self.data.getncattr(name)
    else:
        raise RuntimeError(&#34;parameter &#39;{}&#39; cannot be found!&#34;.format(name))</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_coord_x"><code class="name flex">
<span>def <span class="ident">get_partial_coord_x</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the x coordinate of the specified set of nodes.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_coord_x(self, start, count):
    &#34;&#34;&#34;
    Returns an array containing the x coordinate of the specified set of nodes.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if start &lt; 1:
        raise ValueError(&#34;Start index must be greater than 0&#34;)
    if count &lt; 0:
        raise ValueError(&#34;Count must be a positive integer&#34;)
    num_nodes = self.num_nodes
    if num_nodes == 0:
        return []
    large = self.large_model
    if not large:
        try:
            coord = self.data.variables[VAR_COORD][0][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
    else:
        try:
            coord = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
    return coord</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_coord_y"><code class="name flex">
<span>def <span class="ident">get_partial_coord_y</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the y coordinate of the specified set of nodes.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_coord_y(self, start, count):
    &#34;&#34;&#34;
    Returns an array containing the y coordinate of the specified set of nodes.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if start &lt; 1:
        raise ValueError(&#34;Start index must be greater than 0&#34;)
    if count &lt; 0:
        raise ValueError(&#34;Count must be a positive integer&#34;)
    dim_cnt = self.num_dim
    num_nodes = self.num_nodes
    if num_nodes == 0 or dim_cnt &lt; 2:
        return []
    large = self.large_model
    if not large:
        try:
            coord = self.data.variables[VAR_COORD][1][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
    else:
        try:
            coord = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
    return coord</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_coord_z"><code class="name flex">
<span>def <span class="ident">get_partial_coord_z</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the z coordinate of the specified set of nodes.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_coord_z(self, start, count):
    &#34;&#34;&#34;
    Returns an array containing the z coordinate of the specified set of nodes.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if start &lt; 1:
        raise ValueError(&#34;Start index must be greater than 0&#34;)
    if count &lt; 0:
        raise ValueError(&#34;Count must be a positive integer&#34;)
    dim_cnt = self.num_dim
    num_nodes = self.num_nodes
    if num_nodes == 0 or dim_cnt &lt; 3:
        return []
    large = self.large_model
    if not large:
        try:
            coord = self.data.variables[VAR_COORD][2][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
    else:
        try:
            coord = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
    return coord</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_coords"><code class="name flex">
<span>def <span class="ident">get_partial_coords</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a multidimensional array containing the coordinates of the specified set of nodes.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_coords(self, start, count):
    &#34;&#34;&#34;
    Returns a multidimensional array containing the coordinates of the specified set of nodes.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if start &lt; 1:
        raise ValueError(&#34;Start index must be greater than 0&#34;)
    if count &lt; 0:
        raise ValueError(&#34;Count must be a positive integer&#34;)
    dim_cnt = self.num_dim
    num_nodes = self.num_nodes
    if num_nodes == 0:
        return []
    large = self.large_model
    if not large:
        try:
            coord = self.data.variables[VAR_COORD][:, start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve nodal coordinate array!&#34;)
    else:
        try:
            coordx = self.data.variables[VAR_COORD_X][start - 1:start + count - 1]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve x axis nodal coordinate array!&#34;)
        if dim_cnt &gt; 1:
            try:
                coordy = self.data.variables[VAR_COORD_Y][start - 1:start + count - 1]
            except KeyError:
                raise KeyError(&#34;Failed to retrieve y axis nodal coordinate array!&#34;)
            if dim_cnt &gt; 2:
                try:
                    coordz = self.data.variables[VAR_COORD_Z][start - 1:start + count - 1]
                except KeyError:
                    raise KeyError(&#34;Failed to retrieve z axis nodal coordinate array!&#34;)
                coord = numpy.array([coordx, coordy, coordz])
            else:
                coord = numpy.array([coordx, coordy])
        else:
            coord = coordx
    return coord</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_elem_attrib"><code class="name flex">
<span>def <span class="ident">get_partial_elem_attrib</span></span>(<span>self, obj_id, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial list of all attributes for the specified elements in the element block with given ID.</p>
<p>Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.
Returns an empty array if the element block doesn't have attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_elem_attrib(self, obj_id, start, count):
    &#34;&#34;&#34;
    Returns a partial list of all attributes for the specified elements in the element block with given ID.

    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    Returns an empty array if the element block doesn&#39;t have attributes.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_partial_elem_attrib(obj_id, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_elem_block_connectivity"><code class="name flex">
<span>def <span class="ident">get_partial_elem_block_connectivity</span></span>(<span>self, obj_id, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial connectivity list for the element block with given ID.</p>
<p>Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_elem_block_connectivity(self, obj_id, start, count):
    &#34;&#34;&#34;
    Returns a partial connectivity list for the element block with given ID.

    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_partial_elem_block_connectivity(obj_id, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_elem_block_var_across_times"><code class="name flex">
<span>def <span class="ident">get_partial_elem_block_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index, start_index, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns partial values of an element block variable between specified time steps (inclusive).</p>
<p>Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_elem_block_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                            count):
    &#34;&#34;&#34;
    Returns partial values of an element block variable between specified time steps (inclusive).

    Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_partial_object_var_across_times(ELEMBLOCK, internal_id, start_time_step, end_time_step,
                                                         var_index, start_index, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_elem_id_map"><code class="name flex">
<span>def <span class="ident">get_partial_elem_id_map</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a subset of the element ID map for this database.</p>
<p>Subset starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_elem_id_map(self, start, count):
    &#34;&#34;&#34;
    Return a subset of the element ID map for this database.

    Subset starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
    num_elem = self.num_elem
    if num_elem == 0:
        raise KeyError(&#34;Cannot retrieve a element id map if there are no elements!&#34;)
    if start &lt; 1:
        raise ValueError(&#34;start index must be greater than 0&#34;)
    if start + count - 1 &gt; num_elem:
        raise ValueError(&#34;start index + element count is larger than the total number of elements&#34;)
    if VAR_ELEM_ID_MAP not in self.data.variables:
        # Return a default array from start to start + count exclusive
        warnings.warn(&#34;There is no element id map in this database!&#34;)
        return numpy.arange(start, start + count, dtype=self.int)
    return self.data.variables[VAR_ELEM_ID_MAP][start - 1:start + count - 1]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_nodal_var_across_times"><code class="name flex">
<span>def <span class="ident">get_partial_nodal_var_across_times</span></span>(<span>self, start_time_step, end_time_step, var_index, start_index, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns partial values of a nodal variable between specified time steps (inclusive).</p>
<p>Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_nodal_var_across_times(self, start_time_step, end_time_step, var_index, start_index, count):
    &#34;&#34;&#34;
    Returns partial values of a nodal variable between specified time steps (inclusive).

    Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if self.num_nodes == 0:
        return [[]]
    num_steps = self.num_time_steps
    if num_steps &lt;= 0:
        raise ValueError(&#34;There are no time steps in this database!&#34;)
    if start_time_step &lt;= 0 or start_time_step &gt; num_steps:
        raise ValueError(&#34;Start time step out of range. Got {}&#34;.format(start_time_step))
    if end_time_step &lt;= 0 or end_time_step &lt; start_time_step or end_time_step &gt; num_steps:
        raise ValueError(&#34;End time step out of range. Got {}&#34;.format(end_time_step))
    if var_index &lt;= 0 or var_index &gt; self.num_node_var:
        raise ValueError(&#34;Variable index out of range. Got {}&#34;.format(var_index))
    if start_index &lt;= 0:
        raise ValueError(&#34;Start index must be greater than 0&#34;)
    if count &lt; 0:
        raise ValueError(&#34;Count must be a positive integer&#34;)
    if not self.large_model:
        # All vars stored in one variable
        try:
            # Do not subtract 1 from end (inclusive)
            result = self.data.variables[VAR_VALS_NOD_VAR_SMALL][
                     start_time_step - 1:end_time_step, var_index - 1, start_index - 1:start_index + count - 1]
        except KeyError:
            raise KeyError(&#34;Could not find the nodal variables in this database!&#34;)
    else:
        # Each var to its own variable
        try:
            result = self.data.variables[VAR_VALS_NOD_VAR_LARGE % var_index][start_time_step - 1:end_time_step, :]
        except KeyError:
            raise KeyError(&#34;Could not find nodal variable {} in this database!&#34;.format(var_index))
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_node_id_map"><code class="name flex">
<span>def <span class="ident">get_partial_node_id_map</span></span>(<span>self, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a subset of the node ID map for this database.</p>
<p>Subset starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_id_map(self, start, count):
    &#34;&#34;&#34;
    Return a subset of the node ID map for this database.

    Subset starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    # Start is 1 based (&gt;0).  start + count - 1 &lt;= number of nodes
    num_nodes = self.num_nodes
    if num_nodes == 0:
        raise KeyError(&#34;Cannot retrieve a node id map if there are no nodes!&#34;)
    if start &lt; 1:
        raise ValueError(&#34;start index must be greater than 0&#34;)
    if start + count - 1 &gt; num_nodes:
        raise ValueError(&#34;start index + node count is larger than the total number of nodes&#34;)
    if VAR_NODE_ID_MAP not in self.data.variables:
        # Return a default array from start to start + count exclusive
        warnings.warn(&#34;There is no node id map in this database!&#34;)
        return numpy.arange(start, start + count, dtype=self.int)
    return self.data.variables[VAR_NODE_ID_MAP][start - 1:start + count - 1]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_node_set"><code class="name flex">
<span>def <span class="ident">get_partial_node_set</span></span>(<span>self, identifier, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial array of the nodes contained in the node set with given ID.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_set(self, identifier, start, count):
    &#34;&#34;&#34;
    Returns a partial array of the nodes contained in the node set with given ID.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    if self.mode == &#39;w&#39; or self.mode == &#39;a&#39;:
        return self.ledger.get_partial_node_set(identifier, start, count)

    internal_id = self._lookup_id(NODESET, identifier)
    return self._int_get_partial_node_set(identifier, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_node_set_df"><code class="name flex">
<span>def <span class="ident">get_partial_node_set_df</span></span>(<span>self, obj_id, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial array of the distribution factors contained in the node set with given ID.</p>
<p>Array starts at node number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_set_df(self, obj_id, start, count):
    &#34;&#34;&#34;
    Returns a partial array of the distribution factors contained in the node set with given ID.

    Array starts at node number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(NODESET, obj_id)
    return self._int_get_partial_node_set_df(obj_id, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_node_set_var_across_times"><code class="name flex">
<span>def <span class="ident">get_partial_node_set_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index, start_index, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns partial values of a node set variable between specified time steps (inclusive).</p>
<p>Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_node_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                          count):
    &#34;&#34;&#34;
    Returns partial values of a node set variable between specified time steps (inclusive).

    Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(NODESET, obj_id)
    return self._int_get_partial_object_var_across_times(NODESET, internal_id, start_time_step, end_time_step,
                                                         var_index, start_index, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_one_elem_attrib"><code class="name flex">
<span>def <span class="ident">get_partial_one_elem_attrib</span></span>(<span>self, obj_id, attrib_index, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial list of one attribute for the specified elements in the element block with given ID.</p>
<p>Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.
Returns an empty array if the element block doesn't have attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_one_elem_attrib(self, obj_id, attrib_index, start, count):
    &#34;&#34;&#34;
    Returns a partial list of one attribute for the specified elements in the element block with given ID.

    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    Returns an empty array if the element block doesn&#39;t have attributes.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(ELEMBLOCK, obj_id)
    return self._int_get_partial_one_elem_attrib(obj_id, internal_id, attrib_index, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_side_set"><code class="name flex">
<span>def <span class="ident">get_partial_side_set</span></span>(<span>self, obj_id, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple containing a subset of the elements and sides contained in the side set with given ID.</p>
<p>Arrays start at element number <code>start</code> (1-based) and contains <code>count</code> elements.
Returned tuple is of format (elements in side set, sides in side set).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_side_set(self, obj_id, start, count):
    &#34;&#34;&#34;
    Returns tuple containing a subset of the elements and sides contained in the side set with given ID.

    Arrays start at element number ``start`` (1-based) and contains ``count`` elements.
    Returned tuple is of format (elements in side set, sides in side set).
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    return self._int_get_partial_side_set(obj_id, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_side_set_df"><code class="name flex">
<span>def <span class="ident">get_partial_side_set_df</span></span>(<span>self, obj_id, start, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a partial array of the distribution factors contained in the side set with given ID.</p>
<p>Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_side_set_df(self, obj_id, start, count):
    &#34;&#34;&#34;
    Returns a partial array of the distribution factors contained in the side set with given ID.

    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    return self._int_get_partial_side_set_df(obj_id, internal_id, start, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_partial_side_set_var_across_times"><code class="name flex">
<span>def <span class="ident">get_partial_side_set_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index, start_index, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns partial values of a side set variable between specified time steps (inclusive).</p>
<p>Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
Array starts at element number <code>start</code> (1-based) and contains <code>count</code> elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partial_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index, start_index,
                                          count):
    &#34;&#34;&#34;
    Returns partial values of a side set variable between specified time steps (inclusive).

    Time steps, variable index, ID and start index are all 1-based. First time step is at 1, last at num_time_steps.
    Array starts at element number ``start`` (1-based) and contains ``count`` elements.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                         var_index, start_index, count)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_qa"><code class="name flex">
<span>def <span class="ident">get_qa</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an n x 4 array containing the QA records stored in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qa(self):
    &#34;&#34;&#34;Returns an n x 4 array containing the QA records stored in this database.&#34;&#34;&#34;
    num = self.num_qa
    result = numpy.empty([num, 4], Exodus._MAX_STR_LENGTH_T)
    if num &gt; 0:
        try:
            qas = self.data.variables[VAR_QA]
        except KeyError:
            raise KeyError(&#34;Failed to retrieve qa records from database!&#34;)
        for i in range(num):
            for j in range(4):
                result[i, j] = util.lineparse(qas[i, j])
    return result</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_reverse_elem_id_dict"><code class="name flex">
<span>def <span class="ident">get_reverse_elem_id_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reverse_elem_id_dict(self):
    &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
    eim = self.get_elem_id_map()
    u2i_map = {}
    for i in range(self.num_elem):
        u2i_map[eim[i]] = i + 1
    return u2i_map</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_reverse_node_id_dict"><code class="name flex">
<span>def <span class="ident">get_reverse_node_id_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reverse_node_id_dict(self):
    &#34;&#34;&#34;Returns a dictionary with user-defined IDs as the keys and internal IDs as the values.&#34;&#34;&#34;
    nim = self.get_node_id_map()
    u2i_map = {}
    for i in range(self.num_nodes):
        u2i_map[nim[i]] = i + 1
    return u2i_map</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set"><code class="name flex">
<span>def <span class="ident">get_side_set</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple containing the elements and sides contained in the side set with given ID.</p>
<p>Returned tuple is of format (elements in side set, sides in side set).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set(self, obj_id):
    &#34;&#34;&#34;
    Returns tuple containing the elements and sides contained in the side set with given ID.

    Returned tuple is of format (elements in side set, sides in side set).
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    size = self._int_get_side_set_params(obj_id, internal_id)[0]
    return self._int_get_partial_side_set(obj_id, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_df"><code class="name flex">
<span>def <span class="ident">get_side_set_df</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the distribution factors in the side set with given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_df(self, obj_id):
    &#34;&#34;&#34;Returns an array containing the distribution factors in the side set with given ID.&#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    size = self._int_get_side_set_params(obj_id, internal_id)[1]
    return self._int_get_partial_side_set_df(obj_id, internal_id, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_id_map"><code class="name flex">
<span>def <span class="ident">get_side_set_id_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the id map for side sets (ss_prop1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_id_map(self):
    &#34;&#34;&#34;Returns the id map for side sets (ss_prop1).&#34;&#34;&#34;
    try:
        table = self.data.variables[VAR_SS_ID_MAP][:]
    except KeyError:
        raise KeyError(&#34;Side set id map is missing from this database!&#34;.format(type))
    return table</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_name"><code class="name flex">
<span>def <span class="ident">get_side_set_name</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the given side set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_name(self, obj_id):
    &#34;&#34;&#34;Returns the name of the given side set.&#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    names = self._get_set_block_names(SIDESET)
    if len(names) &gt; 0:
        return names[internal_id - 1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_names"><code class="name flex">
<span>def <span class="ident">get_side_set_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array containing the names of side sets in this database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_names(self):
    &#34;&#34;&#34;Returns an array containing the names of side sets in this database.&#34;&#34;&#34;
    return self._get_set_block_names(SIDESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_node_count_list"><code class="name flex">
<span>def <span class="ident">get_side_set_node_count_list</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns array of number of nodes per side/face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_node_count_list(self, obj_id):
    &#34;&#34;&#34;Returns array of number of nodes per side/face.&#34;&#34;&#34;
    # Adapted from ex_get_side_set_node_count.c
    internal_id = self._lookup_id(SIDESET, obj_id)
    num_eb = self.num_elem_blk
    ndim = self.num_dim
    num_ss_elem, _ = self._int_get_side_set_params(obj_id, internal_id)
    elem_list, side_list = self.get_side_set(obj_id)
    ss_elem_idx = numpy.argsort(elem_list)
    eb_id_map = self.get_elem_block_id_map()
    eb_params = []
    elem_ctr = 0
    for i in range(num_eb):
        id = eb_id_map[i]
        eb_params.append(self._int_get_elem_block_param_object(id, ndim))
        elem_ctr += eb_params[i].num_elem_in_blk
        eb_params[i].elem_ctr = elem_ctr
    node_count_list = numpy.empty(num_ss_elem, self.int)
    j = 0  # current elem block
    for ii in range(num_ss_elem):
        i = ss_elem_idx[ii]
        elem = elem_list[i]
        side = side_list[i] - 1  # 0 based side
        while j &lt; num_eb:
            if elem &lt;= eb_params[j].elem_ctr:
                break
            else:
                j += 1
        if j &gt;= num_eb:
            raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
        if side &gt;= eb_params[j].num_sides:
            raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                             (side, eb_params[j].elem_type_str, obj_id))
        node_count_list[i] = eb_params[j].num_nodes_per_side[side]
    return node_count_list</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_node_list"><code class="name flex">
<span>def <span class="ident">get_side_set_node_list</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns array of nodes for this side set and the node count list.</p>
<p>:return: (node list, node count list)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_node_list(self, obj_id):
    &#34;&#34;&#34;
    Returns array of nodes for this side set and the node count list.

    :return: (node list, node count list)
    &#34;&#34;&#34;
    # Adapted from ex_get_side_set_node_list.c.
    # I really really really hope this doesn&#39;t have errors in it
    internal_id = self._lookup_id(SIDESET, obj_id)
    num_eb = self.num_elem_blk
    num_elem = self.num_elem
    ndim = self.num_dim
    num_ss_elem, num_ss_df = self._int_get_side_set_params(obj_id, internal_id)
    elem_list, side_list = self.get_side_set(obj_id)
    ss_elem_idx = numpy.argsort(elem_list)
    eb_id_map = self.get_elem_block_id_map()
    eb_params = []
    elem_ctr = 0
    for i in range(num_eb):
        id = eb_id_map[i]
        eb_params.append(self._int_get_elem_block_param_object(id, ndim))
        elem_ctr += eb_params[i].num_elem_in_blk
        eb_params[i].elem_ctr = elem_ctr
    ss_param_idx = numpy.empty(num_ss_elem, int)  # ss element to eb param index
    ss_elem_node_idx = numpy.empty(num_ss_elem, int)  # ss element to node list index
    node_count_list = numpy.empty(num_ss_elem, self.int)
    node_ctr = 0
    j = 0  # current elem block
    for ii in range(num_ss_elem):
        i = ss_elem_idx[ii]
        elem = elem_list[i]
        side = side_list[i]
        while j &lt; num_eb:
            if eb_params[j].elem_type_val != NULL:
                if elem &lt;= eb_params[j].elem_ctr:
                    break
                else:
                    j += 1
        if j &gt;= num_eb:
            raise ValueError(&#34;Invalid element number %d in side set %d!&#34; % (elem, obj_id))
        if side &gt;= eb_params[j].num_sides:
            raise ValueError(&#34;Invalid side number %d for element type %s in side set %d!&#34; %
                             (side, eb_params[j].elem_type_str, obj_id))
        ss_param_idx[i] = j
        ss_elem_node_idx[i] = eb_params[j].num_nodes_per_side[side - 1]
        node_ctr += eb_params[j].num_nodes_per_side[side - 1]

    if num_ss_df &gt; 0 and num_ss_df != num_ss_elem:
        if node_ctr != num_ss_df:
            warnings.warn(&#34;Side set %d dist fact count (%d) does not match node list length (%d)! This may indicate&#34;
                          &#34; a corrupt database.&#34; % (obj_id, num_ss_df, node_ctr))

    for i in range(num_ss_elem):
        node_count_list[i] = ss_elem_node_idx[i]

    sum = 0
    for i in range(num_ss_elem):
        cnt = ss_elem_node_idx[i]
        ss_elem_node_idx[i] = sum
        sum += cnt

    node_list = numpy.empty(node_ctr, self.int)

    elem_ctr = 0
    connect = None
    for j in range(num_ss_elem):
        elem_idx = ss_elem_idx[j]
        elem = elem_list[elem_idx]
        side = side_list[elem_idx]
        param_idx = ss_param_idx[elem_idx]

        if elem &gt; elem_ctr:
            # We&#39;re doing this the C way because copying code from SEACAS saves development time
            connect = numpy.ndarray.flatten(self.get_elem_block_connectivity(eb_params[param_idx].elem_blk_id))
            elem_ctr = eb_params[param_idx].elem_ctr

        if connect is None:
            raise ValueError(&#34;connect is None in get_side_set_node_list. This is likely the result of an abnormal&#34;
                             &#34; Exodus file.&#34;)

        elem_num = elem - 1
        elem_num_pos = elem_num - (eb_params[param_idx].elem_ctr - eb_params[param_idx].num_elem_in_blk)

        num_nodes_per_elem = eb_params[param_idx].num_nodes_per_elem
        connect_offset = num_nodes_per_elem * elem_num_pos
        side_num = side - 1
        node_pos = ss_elem_node_idx[elem_idx]

        if eb_params[param_idx].elem_type_val == CIRCLE or eb_params[param_idx].elem_type_val == SPHERE:
            node_list[node_pos] = connect[connect_offset]
        elif eb_params[param_idx].elem_type_val == TRUSS:
            node_list[node_pos] = connect[connect_offset + side_num]
        elif eb_params[param_idx].elem_type_val == BEAM:
            for i in range(num_nodes_per_elem):
                node_list[node_pos + i] = connect[connect_offset + i]
        elif eb_params[param_idx].elem_type_val == TRIANGLE:
            if ndim == 2:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 3:
                    raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                node_list[node_pos] = connect[connect_offset + tri_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + tri_table[side_num][1] - 1]
                if num_nodes_per_elem &gt; 3:
                    node_list[node_pos + 2] = connect[connect_offset + tri_table[side_num][2] - 1]
            elif ndim == 3:
                if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                    raise ValueError(&#34;Invalid triangle side number %d!&#34; % (side_num + 1))
                node_list[node_pos] = connect[connect_offset + tri3_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + tri3_table[side_num][1] - 1]
                if side_num + 1 &lt;= 2:
                    if num_nodes_per_elem == 3:
                        node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                    elif num_nodes_per_elem == 4:
                        node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                        # This looks wrong, but it&#39;s what the C library does...
                        node_list[node_pos + 2] = connect[connect_offset + 4 - 1]
                    elif num_nodes_per_elem == 6:
                        node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                        node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                        node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                    elif num_nodes_per_elem == 7:
                        node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
                        node_list[node_pos + 3] = connect[connect_offset + tri3_table[side_num][3] - 1]
                        node_list[node_pos + 4] = connect[connect_offset + tri3_table[side_num][4] - 1]
                        node_list[node_pos + 5] = connect[connect_offset + tri3_table[side_num][5] - 1]
                        node_list[node_pos + 6] = connect[connect_offset + tri3_table[side_num][6] - 1]
                    else:
                        raise ValueError(&#34;%d is an unsupported number of nodes for triangle elements!&#34; %
                                         num_nodes_per_elem)
                else:
                    if num_nodes_per_elem &gt; 3:
                        node_list[node_pos + 2] = connect[connect_offset + tri3_table[side_num][2] - 1]
        elif eb_params[param_idx].elem_type_val == QUAD:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                raise ValueError(&#34;Invalid quad side number %d!&#34; % (side_num + 1))
            node_list[node_pos + 0] = connect[connect_offset + quad_table[side_num][0] - 1]
            node_list[node_pos + 1] = connect[connect_offset + quad_table[side_num][1] - 1]
            if num_nodes_per_elem &gt; 5:
                node_list[node_pos + 2] = connect[connect_offset + quad_table[side_num][2] - 1]
        elif eb_params[param_idx].elem_type_val == SHELL:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                raise ValueError(&#34;Invalid shell side number %d!&#34; % (side_num + 1))
            node_list[node_pos + 0] = connect[connect_offset + shell_table[side_num][0] - 1]
            node_list[node_pos + 1] = connect[connect_offset + shell_table[side_num][1] - 1]
            if num_nodes_per_elem &gt; 2:
                if side_num + 1 &lt;= 2:
                    node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
                    node_list[node_pos + 3] = connect[connect_offset + shell_table[side_num][3] - 1]
            if num_nodes_per_elem == 8:
                if side_num + 1 &lt;= 2:
                    node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                    node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                else:
                    node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
            if num_nodes_per_elem == 9:
                if side_num + 1 &lt;= 2:
                    node_list[node_pos + 4] = connect[connect_offset + shell_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + shell_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + shell_table[side_num][6] - 1]
                    node_list[node_pos + 7] = connect[connect_offset + shell_table[side_num][7] - 1]
                    node_list[node_pos + 8] = connect[connect_offset + shell_table[side_num][8] - 1]
                else:
                    node_list[node_pos + 2] = connect[connect_offset + shell_table[side_num][2] - 1]
        elif eb_params[param_idx].elem_type_val == TETRA:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 4:
                raise ValueError(&#34;Invalid tetra side number %d!&#34; % (side_num + 1))
            node_list[node_pos + 0] = connect[connect_offset + tetra_table[side_num][0] - 1]
            node_list[node_pos + 1] = connect[connect_offset + tetra_table[side_num][1] - 1]
            node_list[node_pos + 2] = connect[connect_offset + tetra_table[side_num][2] - 1]
            if num_nodes_per_elem == 8:
                node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
            elif num_nodes_per_elem &gt; 8:
                node_list[node_pos + 3] = connect[connect_offset + tetra_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + tetra_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + tetra_table[side_num][5] - 1]
        elif eb_params[param_idx].elem_type_val == WEDGE:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                raise ValueError(&#34;Invalid wedge side number %d!&#34; % (side_num + 1))
            if num_nodes_per_elem == 6 or num_nodes_per_elem == 7:
                node_list[node_pos + 0] = connect[connect_offset + wedge6_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge6_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge6_table[side_num][2] - 1]
                if side_num == 3 or side_num == 4:
                    pass
                else:
                    node_list[node_pos + 3] = connect[connect_offset + wedge6_table[side_num][3] - 1]
            elif num_nodes_per_elem == 15 or num_nodes_per_elem == 16:
                node_list[node_pos + 0] = connect[connect_offset + wedge15_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge15_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge15_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + wedge15_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + wedge15_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + wedge15_table[side_num][5] - 1]
                if side_num == 3 or side_num == 4:
                    pass
                else:
                    node_list[node_pos + 6] = connect[connect_offset + wedge15_table[side_num][6] - 1]
                    node_list[node_pos + 7] = connect[connect_offset + wedge15_table[side_num][7] - 1]
            elif num_nodes_per_elem == 12:
                node_list[node_pos + 0] = connect[connect_offset + wedge12_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge12_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge12_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + wedge12_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + wedge12_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + wedge12_table[side_num][5] - 1]
            elif num_nodes_per_elem == 20:
                node_list[node_pos + 0] = connect[connect_offset + wedge20_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge20_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge20_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + wedge20_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + wedge20_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + wedge20_table[side_num][5] - 1]
                node_list[node_pos + 6] = connect[connect_offset + wedge20_table[side_num][6] - 1]
                if side_num == 3 or side_num == 4:
                    pass
                else:
                    node_list[node_pos + 7] = connect[connect_offset + wedge20_table[side_num][7] - 1]
                    node_list[node_pos + 8] = connect[connect_offset + wedge20_table[side_num][8] - 1]
            elif num_nodes_per_elem == 21:
                node_list[node_pos + 0] = connect[connect_offset + wedge21_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge21_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge21_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + wedge21_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + wedge21_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + wedge21_table[side_num][5] - 1]
                node_list[node_pos + 6] = connect[connect_offset + wedge21_table[side_num][6] - 1]
                if side_num == 3 or side_num == 4:
                    pass
                else:
                    node_list[node_pos + 7] = connect[connect_offset + wedge21_table[side_num][7] - 1]
                    node_list[node_pos + 8] = connect[connect_offset + wedge21_table[side_num][8] - 1]
            elif num_nodes_per_elem == 18:
                node_list[node_pos + 0] = connect[connect_offset + wedge18_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + wedge18_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + wedge18_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + wedge18_table[side_num][3] - 1]
                node_list[node_pos + 4] = connect[connect_offset + wedge18_table[side_num][4] - 1]
                node_list[node_pos + 5] = connect[connect_offset + wedge18_table[side_num][5] - 1]
                if side_num == 3 or side_num == 4:
                    pass
                else:
                    node_list[node_pos + 6] = connect[connect_offset + wedge18_table[side_num][6] - 1]
                    node_list[node_pos + 7] = connect[connect_offset + wedge18_table[side_num][7] - 1]
                    node_list[node_pos + 8] = connect[connect_offset + wedge18_table[side_num][8] - 1]
        elif eb_params[param_idx].elem_type_val == PYRAMID:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 5:
                raise ValueError(&#34;Invalid pyramid side number %d!&#34; % (side_num + 1))
            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][0] - 1]
            node_pos += 1
            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][1] - 1]
            node_pos += 1
            node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][2] - 1]
            node_pos += 1
            if pyramid_table[side_num][3] == 0:
                pass  # this one even confuses the C library
            else:
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][3] - 1]
                node_pos += 1
            if num_nodes_per_elem &gt; 5:
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][4] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][5] - 1]
                node_pos += 1
                node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][6] - 1]
                node_pos += 1
                if side_num == 4:
                    node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][7] - 1]
                    node_pos += 1
                    if num_nodes_per_elem &gt;= 14:
                        node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                        node_pos += 1
                else:
                    if num_nodes_per_elem &gt;= 18:
                        node_list[node_pos] = connect[connect_offset + pyramid_table[side_num][8] - 1]
                        node_pos += 1
        elif eb_params[param_idx].elem_type_val == HEX:
            if side_num + 1 &lt; 1 or side_num + 1 &gt; 6:
                raise ValueError(&#34;Invalid hex side number %d!&#34; % (side_num + 1))
            if num_nodes_per_elem == 16:
                node_list[node_pos + 0] = connect[connect_offset + hex16_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + hex16_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + hex16_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][3] - 1]
                # I have no idea whats going on with these next two statements
                node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][4] - 1]
                node_list[node_pos + 3] = connect[connect_offset + hex16_table[side_num][5] - 1]
                if side_num + 1 == 5 or side_num + 1 == 6:
                    # Also no idea about these ones
                    node_list[node_pos] = connect[connect_offset + hex16_table[side_num][6] - 1]
                    node_pos += 1
                    node_list[node_pos] = connect[connect_offset + hex16_table[side_num][7] - 1]
                    node_pos += 1
            else:
                node_list[node_pos + 0] = connect[connect_offset + hex_table[side_num][0] - 1]
                node_list[node_pos + 1] = connect[connect_offset + hex_table[side_num][1] - 1]
                node_list[node_pos + 2] = connect[connect_offset + hex_table[side_num][2] - 1]
                node_list[node_pos + 3] = connect[connect_offset + hex_table[side_num][3] - 1]
                if num_nodes_per_elem &gt; 12:
                    node_list[node_pos + 4] = connect[connect_offset + hex_table[side_num][4] - 1]
                    node_list[node_pos + 5] = connect[connect_offset + hex_table[side_num][5] - 1]
                    node_list[node_pos + 6] = connect[connect_offset + hex_table[side_num][6] - 1]
                    node_list[node_pos + 7] = connect[connect_offset + hex_table[side_num][7] - 1]
                if num_nodes_per_elem == 27:
                    node_list[node_pos + 8] = connect[connect_offset + hex_table[side_num][8] - 1]
        else:
            raise ValueError(&#34;%s is an unsupported element type.&#34; % eb_params[param_idx].elem_type_str)
    return node_list, node_count_list</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_number"><code class="name flex">
<span>def <span class="ident">get_side_set_number</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the internal ID (1-based) of the side set with the user-defined ID.</p>
<p>Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
create an ID lookup table yourself if you plan to convert IDs often.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_number(self, obj_id):
    &#34;&#34;&#34;
    Returns the internal ID (1-based) of the side set with the user-defined ID.

    Note that this function is O(n) complexity for n number of node sets. While useful for quick tests, you should
    create an ID lookup table yourself if you plan to convert IDs often.
    &#34;&#34;&#34;
    return self._lookup_id(SIDESET, obj_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_params"><code class="name flex">
<span>def <span class="ident">get_side_set_params</span></span>(<span>self, obj_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple containing the parameters for the side set with given ID.</p>
<p>Returned tuple is of format (number of elements, number of distribution factors).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_params(self, obj_id):
    &#34;&#34;&#34;
    Returns a tuple containing the parameters for the side set with given ID.

    Returned tuple is of format (number of elements, number of distribution factors).
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    return self._int_get_side_set_params(obj_id, internal_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_property"><code class="name flex">
<span>def <span class="ident">get_side_set_property</span></span>(<span>self, obj_id, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the specified property for the side set with the given ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_property(self, obj_id, name):
    &#34;&#34;&#34;Returns the value of the specified property for the side set with the given ID.&#34;&#34;&#34;
    return self._get_object_property(SIDESET, obj_id, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_property_array"><code class="name flex">
<span>def <span class="ident">get_side_set_property_array</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list containing the values of the specified property for all side sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_property_array(self, name):
    &#34;&#34;&#34;Returns a list containing the values of the specified property for all side sets.&#34;&#34;&#34;
    return self._get_object_property_array(SIDESET, name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_property_names"><code class="name flex">
<span>def <span class="ident">get_side_set_property_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of side set property names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_property_names(self):
    &#34;&#34;&#34;Returns a list of side set property names.&#34;&#34;&#34;
    return self._get_object_property_names(SIDESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_truth_table"><code class="name flex">
<span>def <span class="ident">get_side_set_truth_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable truth table for side sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_truth_table(self):
    &#34;&#34;&#34;Returns the variable truth table for side sets.&#34;&#34;&#34;
    return self._get_truth_table(SIDESET)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_var_across_times"><code class="name flex">
<span>def <span class="ident">get_side_set_var_across_times</span></span>(<span>self, obj_id, start_time_step, end_time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the side set with id between time steps (inclusive).</p>
<p>Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_var_across_times(self, obj_id, start_time_step, end_time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the side set with id between time steps (inclusive).

    Time steps, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    internal_id = self._lookup_id(SIDESET, obj_id)
    size = self._int_get_side_set_params(obj_id, internal_id)[0]
    return self._int_get_partial_object_var_across_times(SIDESET, internal_id, start_time_step, end_time_step,
                                                         var_index, 1, size)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_var_at_time"><code class="name flex">
<span>def <span class="ident">get_side_set_var_at_time</span></span>(<span>self, obj_id, time_step, var_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the values of variable with index stored in the side set with id at time step.</p>
<p>Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_var_at_time(self, obj_id, time_step, var_index):
    &#34;&#34;&#34;
    Returns the values of variable with index stored in the side set with id at time step.

    Time step, variable index, and ID are all 1-based. First time step is at 1, last at num_time_steps.
    &#34;&#34;&#34;
    return self.get_side_set_var_across_times(obj_id, time_step, time_step, var_index)[0]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_var_name"><code class="name flex">
<span>def <span class="ident">get_side_set_var_name</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the side set variable with the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_var_name(self, index):
    &#34;&#34;&#34;Returns the name of the side set variable with the given index.&#34;&#34;&#34;
    return self._get_var_name(SIDESET_VAR, index)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_side_set_var_names"><code class="name flex">
<span>def <span class="ident">get_side_set_var_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all node set variable names. Index of the variable is the index of the name + 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_side_set_var_names(self):
    &#34;&#34;&#34;Returns a list of all node set variable names. Index of the variable is the index of the name + 1.&#34;&#34;&#34;
    return self._get_var_names(SIDESET_VAR)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self, time_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time value for specified time step.</p>
<p>Time steps are 1-indexed. The first time step is at 1, and the last at num_time_steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self, time_step):
    &#34;&#34;&#34;
    Returns the time value for specified time step.

    Time steps are 1-indexed. The first time step is at 1, and the last at num_time_steps.
    &#34;&#34;&#34;
    num_steps = self.num_time_steps
    if num_steps &lt;= 0:
        raise ValueError(&#34;There are no time steps in this database!&#34;)
    if time_step &lt;= 0 or time_step &gt; num_steps:
        raise ValueError(&#34;Time step out of range. Got {}&#34;.format(time_step))
    return self.get_all_times()[time_step - 1]</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.has_var_names"><code class="name flex">
<span>def <span class="ident">has_var_names</span></span>(<span>self, var_type: constants.VariableType)</span>
</code></dt>
<dd>
<div class="desc"><p>.Test if this Exodus file has variable names for a variable type.</p>
<p>:param var_type: GLOBAL_VAR, NODAL_VAR, ELEMENTAL_VAR, NODESET_VAR, or SIDESET_VAR from <code>constants</code>
:return: True if this variable type has names defined, false otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_var_names(self, var_type: VariableType):
    &#34;&#34;&#34;
    .Test if this Exodus file has variable names for a variable type.

    :param var_type: GLOBAL_VAR, NODAL_VAR, ELEMENTAL_VAR, NODESET_VAR, or SIDESET_VAR from `constants`
    :return: True if this variable type has names defined, false otherwise
    &#34;&#34;&#34;
    if var_type == GLOBAL_VAR:
        varname = VAR_NAME_GLO_VAR
    elif var_type == NODAL_VAR:
        varname = VAR_NAME_NOD_VAR
    elif var_type == ELEMENTAL_VAR:
        varname = VAR_NAME_ELEM_VAR
    elif var_type == NODESET_VAR:
        varname = VAR_NAME_NS_VAR
    elif var_type == SIDESET_VAR:
        varname = VAR_NAME_SS_VAR
    else:
        raise ValueError(&#34;Invalid variable type {}!&#34;.format(var_type))
    return varname in self.data.variables</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.merge_nodeset"><code class="name flex">
<span>def <span class="ident">merge_nodeset</span></span>(<span>self, new_id, ns1, ns2, delete=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_nodeset(self, new_id, ns1, ns2, delete=True):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.merge_nodesets(new_id, ns1, ns2, delete)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.print_dimension_names"><code class="name flex">
<span>def <span class="ident">print_dimension_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_dimension_names(self):
    for dim in self.data.dimensions:
        print(dim)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.print_dimensions"><code class="name flex">
<span>def <span class="ident">print_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_dimensions(self):
    for dim in self.data.dimensions.values():
        print(dim)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.print_variable_names"><code class="name flex">
<span>def <span class="ident">print_variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_variable_names(self):
    for v in self.data.variables:
        print(v)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.print_variables"><code class="name flex">
<span>def <span class="ident">print_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_variables(self):
    for v in self.data.variables.values():
        print(v, &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_element"><code class="name flex">
<span>def <span class="ident">remove_element</span></span>(<span>self, elem_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_element(self, elem_id):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    return self.ledger.remove_element(elem_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_node_from_nodeset"><code class="name flex">
<span>def <span class="ident">remove_node_from_nodeset</span></span>(<span>self, node_id, identifier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node_from_nodeset(self, node_id, identifier):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.remove_node_from_nodeset(node_id, identifier)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_nodes_from_nodeset"><code class="name flex">
<span>def <span class="ident">remove_nodes_from_nodeset</span></span>(<span>self, node_ids, identifier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_nodes_from_nodeset(self, node_ids, identifier):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.remove_nodes_from_nodeset(node_ids, identifier)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_nodeset"><code class="name flex">
<span>def <span class="ident">remove_nodeset</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_nodeset(self, identifier):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.remove_nodeset(identifier)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_sides_from_sideset"><code class="name flex">
<span>def <span class="ident">remove_sides_from_sideset</span></span>(<span>self, elem_ids, side_ids, ss_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_sides_from_sideset(self, elem_ids, side_ids, ss_id):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.remove_sides_from_sideset(elem_ids, side_ids, ss_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.remove_sideset"><code class="name flex">
<span>def <span class="ident">remove_sideset</span></span>(<span>self, ss_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_sideset(self, ss_id):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to add nodeset&#34;)
    self.ledger.remove_sideset(ss_id)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.set_nodeset"><code class="name flex">
<span>def <span class="ident">set_nodeset</span></span>(<span>self, node_set_id, node_ids)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nodeset(self, node_set_id, node_ids):
    ndx = node_set_id - 1
    if &#34;ns_prop1&#34; in self.data.variables:
        ndx = numpy.where(self.data.variables[&#34;ns_prop1&#34;][:] == node_set_id)[0][0]
        ndx += 1

    key = &#34;node_ns&#34; + str(ndx)
    nodeset = self.data[key]

    if &#34;node_num_map&#34; in self.data.variables:
        indices = numpy.zeros(len(node_ids))
        i = 0
        for id in node_ids:
            ndx = numpy.where(self.data[&#34;node_num_map&#34;][:] == id)[0][0]
            indices[i] = ndx
            i += 1
        nodeset[:] = indices
        return
    nodeset[:] = node_ids</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.skin"><code class="name flex">
<span>def <span class="ident">skin</span></span>(<span>self, skin_id, skin_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skin(self, skin_id, skin_name):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
    self.ledger.skin(skin_id, skin_name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.skin_element_block"><code class="name flex">
<span>def <span class="ident">skin_element_block</span></span>(<span>self, block_id, skin_id, skin_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skin_element_block(self, block_id, skin_id, skin_name):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to skin element into new sideset&#34;)
    self.ledger.skin_element_block(block_id, skin_id, skin_name)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.split_sideset"><code class="name flex">
<span>def <span class="ident">split_sideset</span></span>(<span>self, old_ss, function, ss_id1, ss_id2, delete, ss_name1='', ss_name2='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_sideset(self, old_ss, function, ss_id1, ss_id2, delete, ss_name1=&#34;&#34;, ss_name2=&#34;&#34;):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to split sideset&#34;)
    self.ledger.split_sideset(old_ss, function, ss_id1, ss_id2, delete, ss_name1, ss_name2)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.step_at_time"><code class="name flex">
<span>def <span class="ident">step_at_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a float time value, return the corresponding time step</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_at_time(self, time):
    &#34;&#34;&#34;Given a float time value, return the corresponding time step&#34;&#34;&#34;
    for index, value in enumerate(self.get_all_times()):
        if value == time:
            return index
    return None</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.to_float"><code class="name flex">
<span>def <span class="ident">to_float</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>n</code> converted to the floating-point type stored in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_float(self, n):
    &#34;&#34;&#34;Returns ``n`` converted to the floating-point type stored in the database.&#34;&#34;&#34;
    # Convert a number to the floating point type the database is using
    return self._float(n)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.to_int"><code class="name flex">
<span>def <span class="ident">to_int</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>n</code> converted to the integer type stored in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_int(self, n):
    &#34;&#34;&#34;Returns ``n`` converted to the integer type stored in the database.&#34;&#34;&#34;
    # Convert a number to the integer type the database is using
    return self._int(n)</code></pre>
</details>
</dd>
<dt id="exodus.Exodus.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, path=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, path=None):
    if self.mode != &#39;w&#39; and self.mode != &#39;a&#39;:
        raise PermissionError(&#34;Need to be in write or append mode to write&#34;)
    elif self.mode == &#39;a&#39; and path is None:
        raise AttributeError(&#34;Must specify a new path when in append mode&#34;)
    elif self.mode == &#39;w&#39; and path is not None:
        raise AttributeError(&#34;Do not specify a new path in write mode. Initialization path will be used&#34;)
    self.ledger.write(path)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exodus.ElemBlockParam" href="#exodus.ElemBlockParam">ElemBlockParam</a></code></h4>
<ul class="two-column">
<li><code><a title="exodus.ElemBlockParam.elem_blk_id" href="#exodus.ElemBlockParam.elem_blk_id">elem_blk_id</a></code></li>
<li><code><a title="exodus.ElemBlockParam.elem_ctr" href="#exodus.ElemBlockParam.elem_ctr">elem_ctr</a></code></li>
<li><code><a title="exodus.ElemBlockParam.elem_type_str" href="#exodus.ElemBlockParam.elem_type_str">elem_type_str</a></code></li>
<li><code><a title="exodus.ElemBlockParam.elem_type_val" href="#exodus.ElemBlockParam.elem_type_val">elem_type_val</a></code></li>
<li><code><a title="exodus.ElemBlockParam.num_attr" href="#exodus.ElemBlockParam.num_attr">num_attr</a></code></li>
<li><code><a title="exodus.ElemBlockParam.num_elem_in_blk" href="#exodus.ElemBlockParam.num_elem_in_blk">num_elem_in_blk</a></code></li>
<li><code><a title="exodus.ElemBlockParam.num_nodes_per_elem" href="#exodus.ElemBlockParam.num_nodes_per_elem">num_nodes_per_elem</a></code></li>
<li><code><a title="exodus.ElemBlockParam.num_nodes_per_side" href="#exodus.ElemBlockParam.num_nodes_per_side">num_nodes_per_side</a></code></li>
<li><code><a title="exodus.ElemBlockParam.num_sides" href="#exodus.ElemBlockParam.num_sides">num_sides</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exodus.Exodus" href="#exodus.Exodus">Exodus</a></code></h4>
<ul class="">
<li><code><a title="exodus.Exodus.add_element" href="#exodus.Exodus.add_element">add_element</a></code></li>
<li><code><a title="exodus.Exodus.add_node_to_nodeset" href="#exodus.Exodus.add_node_to_nodeset">add_node_to_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.add_nodes_to_nodeset" href="#exodus.Exodus.add_nodes_to_nodeset">add_nodes_to_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.add_nodeset" href="#exodus.Exodus.add_nodeset">add_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.add_sides_to_sideset" href="#exodus.Exodus.add_sides_to_sideset">add_sides_to_sideset</a></code></li>
<li><code><a title="exodus.Exodus.add_sideset" href="#exodus.Exodus.add_sideset">add_sideset</a></code></li>
<li><code><a title="exodus.Exodus.api_version" href="#exodus.Exodus.api_version">api_version</a></code></li>
<li><code><a title="exodus.Exodus.close" href="#exodus.Exodus.close">close</a></code></li>
<li><code><a title="exodus.Exodus.diff" href="#exodus.Exodus.diff">diff</a></code></li>
<li><code><a title="exodus.Exodus.diff_nodeset" href="#exodus.Exodus.diff_nodeset">diff_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.float" href="#exodus.Exodus.float">float</a></code></li>
<li><code><a title="exodus.Exodus.get_all_times" href="#exodus.Exodus.get_all_times">get_all_times</a></code></li>
<li><code><a title="exodus.Exodus.get_coord_names" href="#exodus.Exodus.get_coord_names">get_coord_names</a></code></li>
<li><code><a title="exodus.Exodus.get_coord_x" href="#exodus.Exodus.get_coord_x">get_coord_x</a></code></li>
<li><code><a title="exodus.Exodus.get_coord_y" href="#exodus.Exodus.get_coord_y">get_coord_y</a></code></li>
<li><code><a title="exodus.Exodus.get_coord_z" href="#exodus.Exodus.get_coord_z">get_coord_z</a></code></li>
<li><code><a title="exodus.Exodus.get_coords" href="#exodus.Exodus.get_coords">get_coords</a></code></li>
<li><code><a title="exodus.Exodus.get_dimension" href="#exodus.Exodus.get_dimension">get_dimension</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_attrib" href="#exodus.Exodus.get_elem_attrib">get_elem_attrib</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_attrib_names" href="#exodus.Exodus.get_elem_attrib_names">get_elem_attrib_names</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_connectivity" href="#exodus.Exodus.get_elem_block_connectivity">get_elem_block_connectivity</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_id_map" href="#exodus.Exodus.get_elem_block_id_map">get_elem_block_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_name" href="#exodus.Exodus.get_elem_block_name">get_elem_block_name</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_names" href="#exodus.Exodus.get_elem_block_names">get_elem_block_names</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_number" href="#exodus.Exodus.get_elem_block_number">get_elem_block_number</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_params" href="#exodus.Exodus.get_elem_block_params">get_elem_block_params</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_property" href="#exodus.Exodus.get_elem_block_property">get_elem_block_property</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_property_array" href="#exodus.Exodus.get_elem_block_property_array">get_elem_block_property_array</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_property_names" href="#exodus.Exodus.get_elem_block_property_names">get_elem_block_property_names</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_truth_table" href="#exodus.Exodus.get_elem_block_truth_table">get_elem_block_truth_table</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_var_across_times" href="#exodus.Exodus.get_elem_block_var_across_times">get_elem_block_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_block_var_at_time" href="#exodus.Exodus.get_elem_block_var_at_time">get_elem_block_var_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_id_map" href="#exodus.Exodus.get_elem_id_map">get_elem_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_id_map_for_block" href="#exodus.Exodus.get_elem_id_map_for_block">get_elem_id_map_for_block</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_order_map" href="#exodus.Exodus.get_elem_order_map">get_elem_order_map</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_var_name" href="#exodus.Exodus.get_elem_var_name">get_elem_var_name</a></code></li>
<li><code><a title="exodus.Exodus.get_elem_var_names" href="#exodus.Exodus.get_elem_var_names">get_elem_var_names</a></code></li>
<li><code><a title="exodus.Exodus.get_global_var_across_times" href="#exodus.Exodus.get_global_var_across_times">get_global_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_global_var_at_time" href="#exodus.Exodus.get_global_var_at_time">get_global_var_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_global_var_name" href="#exodus.Exodus.get_global_var_name">get_global_var_name</a></code></li>
<li><code><a title="exodus.Exodus.get_global_var_names" href="#exodus.Exodus.get_global_var_names">get_global_var_names</a></code></li>
<li><code><a title="exodus.Exodus.get_global_vars_across_times" href="#exodus.Exodus.get_global_vars_across_times">get_global_vars_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_global_vars_at_time" href="#exodus.Exodus.get_global_vars_at_time">get_global_vars_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_info" href="#exodus.Exodus.get_info">get_info</a></code></li>
<li><code><a title="exodus.Exodus.get_nodal_var_across_times" href="#exodus.Exodus.get_nodal_var_across_times">get_nodal_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_nodal_var_at_time" href="#exodus.Exodus.get_nodal_var_at_time">get_nodal_var_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_nodal_var_name" href="#exodus.Exodus.get_nodal_var_name">get_nodal_var_name</a></code></li>
<li><code><a title="exodus.Exodus.get_nodal_var_names" href="#exodus.Exodus.get_nodal_var_names">get_nodal_var_names</a></code></li>
<li><code><a title="exodus.Exodus.get_node_id_map" href="#exodus.Exodus.get_node_id_map">get_node_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set" href="#exodus.Exodus.get_node_set">get_node_set</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_df" href="#exodus.Exodus.get_node_set_df">get_node_set_df</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_id_map" href="#exodus.Exodus.get_node_set_id_map">get_node_set_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_name" href="#exodus.Exodus.get_node_set_name">get_node_set_name</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_names" href="#exodus.Exodus.get_node_set_names">get_node_set_names</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_number" href="#exodus.Exodus.get_node_set_number">get_node_set_number</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_params" href="#exodus.Exodus.get_node_set_params">get_node_set_params</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_property" href="#exodus.Exodus.get_node_set_property">get_node_set_property</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_property_array" href="#exodus.Exodus.get_node_set_property_array">get_node_set_property_array</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_property_names" href="#exodus.Exodus.get_node_set_property_names">get_node_set_property_names</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_truth_table" href="#exodus.Exodus.get_node_set_truth_table">get_node_set_truth_table</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_var_across_times" href="#exodus.Exodus.get_node_set_var_across_times">get_node_set_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_var_at_time" href="#exodus.Exodus.get_node_set_var_at_time">get_node_set_var_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_var_name" href="#exodus.Exodus.get_node_set_var_name">get_node_set_var_name</a></code></li>
<li><code><a title="exodus.Exodus.get_node_set_var_names" href="#exodus.Exodus.get_node_set_var_names">get_node_set_var_names</a></code></li>
<li><code><a title="exodus.Exodus.get_nodes_in_elblock" href="#exodus.Exodus.get_nodes_in_elblock">get_nodes_in_elblock</a></code></li>
<li><code><a title="exodus.Exodus.get_num_elem_attrib" href="#exodus.Exodus.get_num_elem_attrib">get_num_elem_attrib</a></code></li>
<li><code><a title="exodus.Exodus.get_one_elem_attrib" href="#exodus.Exodus.get_one_elem_attrib">get_one_elem_attrib</a></code></li>
<li><code><a title="exodus.Exodus.get_parameter" href="#exodus.Exodus.get_parameter">get_parameter</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_coord_x" href="#exodus.Exodus.get_partial_coord_x">get_partial_coord_x</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_coord_y" href="#exodus.Exodus.get_partial_coord_y">get_partial_coord_y</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_coord_z" href="#exodus.Exodus.get_partial_coord_z">get_partial_coord_z</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_coords" href="#exodus.Exodus.get_partial_coords">get_partial_coords</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_elem_attrib" href="#exodus.Exodus.get_partial_elem_attrib">get_partial_elem_attrib</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_elem_block_connectivity" href="#exodus.Exodus.get_partial_elem_block_connectivity">get_partial_elem_block_connectivity</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_elem_block_var_across_times" href="#exodus.Exodus.get_partial_elem_block_var_across_times">get_partial_elem_block_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_elem_id_map" href="#exodus.Exodus.get_partial_elem_id_map">get_partial_elem_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_nodal_var_across_times" href="#exodus.Exodus.get_partial_nodal_var_across_times">get_partial_nodal_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_node_id_map" href="#exodus.Exodus.get_partial_node_id_map">get_partial_node_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_node_set" href="#exodus.Exodus.get_partial_node_set">get_partial_node_set</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_node_set_df" href="#exodus.Exodus.get_partial_node_set_df">get_partial_node_set_df</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_node_set_var_across_times" href="#exodus.Exodus.get_partial_node_set_var_across_times">get_partial_node_set_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_one_elem_attrib" href="#exodus.Exodus.get_partial_one_elem_attrib">get_partial_one_elem_attrib</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_side_set" href="#exodus.Exodus.get_partial_side_set">get_partial_side_set</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_side_set_df" href="#exodus.Exodus.get_partial_side_set_df">get_partial_side_set_df</a></code></li>
<li><code><a title="exodus.Exodus.get_partial_side_set_var_across_times" href="#exodus.Exodus.get_partial_side_set_var_across_times">get_partial_side_set_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_qa" href="#exodus.Exodus.get_qa">get_qa</a></code></li>
<li><code><a title="exodus.Exodus.get_reverse_elem_id_dict" href="#exodus.Exodus.get_reverse_elem_id_dict">get_reverse_elem_id_dict</a></code></li>
<li><code><a title="exodus.Exodus.get_reverse_node_id_dict" href="#exodus.Exodus.get_reverse_node_id_dict">get_reverse_node_id_dict</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set" href="#exodus.Exodus.get_side_set">get_side_set</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_df" href="#exodus.Exodus.get_side_set_df">get_side_set_df</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_id_map" href="#exodus.Exodus.get_side_set_id_map">get_side_set_id_map</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_name" href="#exodus.Exodus.get_side_set_name">get_side_set_name</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_names" href="#exodus.Exodus.get_side_set_names">get_side_set_names</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_node_count_list" href="#exodus.Exodus.get_side_set_node_count_list">get_side_set_node_count_list</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_node_list" href="#exodus.Exodus.get_side_set_node_list">get_side_set_node_list</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_number" href="#exodus.Exodus.get_side_set_number">get_side_set_number</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_params" href="#exodus.Exodus.get_side_set_params">get_side_set_params</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_property" href="#exodus.Exodus.get_side_set_property">get_side_set_property</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_property_array" href="#exodus.Exodus.get_side_set_property_array">get_side_set_property_array</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_property_names" href="#exodus.Exodus.get_side_set_property_names">get_side_set_property_names</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_truth_table" href="#exodus.Exodus.get_side_set_truth_table">get_side_set_truth_table</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_var_across_times" href="#exodus.Exodus.get_side_set_var_across_times">get_side_set_var_across_times</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_var_at_time" href="#exodus.Exodus.get_side_set_var_at_time">get_side_set_var_at_time</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_var_name" href="#exodus.Exodus.get_side_set_var_name">get_side_set_var_name</a></code></li>
<li><code><a title="exodus.Exodus.get_side_set_var_names" href="#exodus.Exodus.get_side_set_var_names">get_side_set_var_names</a></code></li>
<li><code><a title="exodus.Exodus.get_time" href="#exodus.Exodus.get_time">get_time</a></code></li>
<li><code><a title="exodus.Exodus.has_var_names" href="#exodus.Exodus.has_var_names">has_var_names</a></code></li>
<li><code><a title="exodus.Exodus.int" href="#exodus.Exodus.int">int</a></code></li>
<li><code><a title="exodus.Exodus.int64_status" href="#exodus.Exodus.int64_status">int64_status</a></code></li>
<li><code><a title="exodus.Exodus.large_model" href="#exodus.Exodus.large_model">large_model</a></code></li>
<li><code><a title="exodus.Exodus.max_allowed_name_length" href="#exodus.Exodus.max_allowed_name_length">max_allowed_name_length</a></code></li>
<li><code><a title="exodus.Exodus.max_line_length" href="#exodus.Exodus.max_line_length">max_line_length</a></code></li>
<li><code><a title="exodus.Exodus.max_string_length" href="#exodus.Exodus.max_string_length">max_string_length</a></code></li>
<li><code><a title="exodus.Exodus.max_used_name_length" href="#exodus.Exodus.max_used_name_length">max_used_name_length</a></code></li>
<li><code><a title="exodus.Exodus.merge_nodeset" href="#exodus.Exodus.merge_nodeset">merge_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.num_dim" href="#exodus.Exodus.num_dim">num_dim</a></code></li>
<li><code><a title="exodus.Exodus.num_elem" href="#exodus.Exodus.num_elem">num_elem</a></code></li>
<li><code><a title="exodus.Exodus.num_elem_blk" href="#exodus.Exodus.num_elem_blk">num_elem_blk</a></code></li>
<li><code><a title="exodus.Exodus.num_elem_block_prop" href="#exodus.Exodus.num_elem_block_prop">num_elem_block_prop</a></code></li>
<li><code><a title="exodus.Exodus.num_elem_block_var" href="#exodus.Exodus.num_elem_block_var">num_elem_block_var</a></code></li>
<li><code><a title="exodus.Exodus.num_global_var" href="#exodus.Exodus.num_global_var">num_global_var</a></code></li>
<li><code><a title="exodus.Exodus.num_info" href="#exodus.Exodus.num_info">num_info</a></code></li>
<li><code><a title="exodus.Exodus.num_node_set_prop" href="#exodus.Exodus.num_node_set_prop">num_node_set_prop</a></code></li>
<li><code><a title="exodus.Exodus.num_node_set_var" href="#exodus.Exodus.num_node_set_var">num_node_set_var</a></code></li>
<li><code><a title="exodus.Exodus.num_node_sets" href="#exodus.Exodus.num_node_sets">num_node_sets</a></code></li>
<li><code><a title="exodus.Exodus.num_node_var" href="#exodus.Exodus.num_node_var">num_node_var</a></code></li>
<li><code><a title="exodus.Exodus.num_nodes" href="#exodus.Exodus.num_nodes">num_nodes</a></code></li>
<li><code><a title="exodus.Exodus.num_qa" href="#exodus.Exodus.num_qa">num_qa</a></code></li>
<li><code><a title="exodus.Exodus.num_side_set_prop" href="#exodus.Exodus.num_side_set_prop">num_side_set_prop</a></code></li>
<li><code><a title="exodus.Exodus.num_side_set_var" href="#exodus.Exodus.num_side_set_var">num_side_set_var</a></code></li>
<li><code><a title="exodus.Exodus.num_side_sets" href="#exodus.Exodus.num_side_sets">num_side_sets</a></code></li>
<li><code><a title="exodus.Exodus.num_time_steps" href="#exodus.Exodus.num_time_steps">num_time_steps</a></code></li>
<li><code><a title="exodus.Exodus.print_dimension_names" href="#exodus.Exodus.print_dimension_names">print_dimension_names</a></code></li>
<li><code><a title="exodus.Exodus.print_dimensions" href="#exodus.Exodus.print_dimensions">print_dimensions</a></code></li>
<li><code><a title="exodus.Exodus.print_variable_names" href="#exodus.Exodus.print_variable_names">print_variable_names</a></code></li>
<li><code><a title="exodus.Exodus.print_variables" href="#exodus.Exodus.print_variables">print_variables</a></code></li>
<li><code><a title="exodus.Exodus.remove_element" href="#exodus.Exodus.remove_element">remove_element</a></code></li>
<li><code><a title="exodus.Exodus.remove_node_from_nodeset" href="#exodus.Exodus.remove_node_from_nodeset">remove_node_from_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.remove_nodes_from_nodeset" href="#exodus.Exodus.remove_nodes_from_nodeset">remove_nodes_from_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.remove_nodeset" href="#exodus.Exodus.remove_nodeset">remove_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.remove_sides_from_sideset" href="#exodus.Exodus.remove_sides_from_sideset">remove_sides_from_sideset</a></code></li>
<li><code><a title="exodus.Exodus.remove_sideset" href="#exodus.Exodus.remove_sideset">remove_sideset</a></code></li>
<li><code><a title="exodus.Exodus.set_nodeset" href="#exodus.Exodus.set_nodeset">set_nodeset</a></code></li>
<li><code><a title="exodus.Exodus.skin" href="#exodus.Exodus.skin">skin</a></code></li>
<li><code><a title="exodus.Exodus.skin_element_block" href="#exodus.Exodus.skin_element_block">skin_element_block</a></code></li>
<li><code><a title="exodus.Exodus.split_sideset" href="#exodus.Exodus.split_sideset">split_sideset</a></code></li>
<li><code><a title="exodus.Exodus.step_at_time" href="#exodus.Exodus.step_at_time">step_at_time</a></code></li>
<li><code><a title="exodus.Exodus.time_steps" href="#exodus.Exodus.time_steps">time_steps</a></code></li>
<li><code><a title="exodus.Exodus.title" href="#exodus.Exodus.title">title</a></code></li>
<li><code><a title="exodus.Exodus.to_float" href="#exodus.Exodus.to_float">to_float</a></code></li>
<li><code><a title="exodus.Exodus.to_int" href="#exodus.Exodus.to_int">to_int</a></code></li>
<li><code><a title="exodus.Exodus.version" href="#exodus.Exodus.version">version</a></code></li>
<li><code><a title="exodus.Exodus.word_size" href="#exodus.Exodus.word_size">word_size</a></code></li>
<li><code><a title="exodus.Exodus.write" href="#exodus.Exodus.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>